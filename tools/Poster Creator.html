<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Poster Creator</title>
    <!-- SEO Tags -->
    <meta name="description" content="Create stunning posters with a powerful online tool. Customize text, fonts, colors, and layouts to design your perfect poster.">
    <meta name="keywords" content="poster creator, design tool, graphic design, custom poster, online editor, typography design">

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Lobster&family=Lato:ital,wght@0,400;0,700;1,400;1,700&family=Montserrat:ital,wght@0,400;0,700;1,400;1,700&family=Oswald:wght@400;700&family=Merriweather:ital,wght@0,400;0,700;1,400;1,700&family=Lora:ital,wght@0,400;0,700;1,400;1,700&family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=Raleway:ital,wght@0,400;0,700;1,400;1,700&family=Alfa+Slab+One&family=Bebas+Neue&family=Pacifico&family=Righteous&family=Indie+Flower&family=Patrick+Hand&family=Dancing+Script:wght@400;700&family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Roboto', sans-serif; overflow: hidden; }
        #loading-overlay { position: fixed; inset: 0; background-color: rgba(255, 255, 255, 0.8); z-index: 9999; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(4px); }
        #controls-content::-webkit-scrollbar { width: 8px; }
        #controls-content::-webkit-scrollbar-track { background: #f1f5f9; }
        #controls-content::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        #poster-canvas { cursor: default; }
        .btn-action { display: flex; align-items: center; justify-content: center; gap: 0.5rem; width: 100%; padding: 0.5rem; border: 1px solid #d1d5db; border-radius: 0.375rem; background-color: white; transition: background-color 0.2s; }
        .btn-action:hover { background-color: #f9fafb; }

        /* Font previews in select dropdown */
        .font-select-merriweather { font-family: 'Merriweather', serif; }
        .font-select-lora { font-family: 'Lora', serif; }
        .font-select-playfair-display { font-family: 'Playfair Display', serif; }
        .font-select-roboto { font-family: 'Roboto', sans-serif; }
        .font-select-lato { font-family: 'Lato', sans-serif; }
        .font-select-montserrat { font-family: 'Montserrat', sans-serif; }
        .font-select-oswald { font-family: 'Oswald', sans-serif; }
        .font-select-raleway { font-family: 'Raleway', sans-serif; }
        .font-select-lobster { font-family: 'Lobster', cursive; }
        .font-select-alfa-slab-one { font-family: 'Alfa Slab One', cursive; }
        .font-select-bebas-neue { font-family: 'Bebas Neue', cursive; }
        .font-select-pacifico { font-family: 'Pacifico', cursive; }
        .font-select-righteous { font-family: 'Righteous', cursive; }
        .font-select-indie-flower { font-family: 'Indie Flower', cursive; }
        .font-select-patrick-hand { font-family: 'Patrick Hand', cursive; }
        .font-select-dancing-script { font-family: 'Dancing Script', cursive; }
        .font-select-caveat { font-family: 'Caveat', cursive; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col lg:flex-row h-screen">

    <div id="loading-overlay">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-indigo-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-lg font-semibold text-gray-700">Loading Fonts...</p>
        </div>
    </div>
    
    <!-- Controls Panel -->
    <div id="controls-panel" class="w-full lg:w-80 xl:w-96 bg-white shadow-lg flex flex-col flex-shrink-0 transition-all duration-300">
        <div class="p-4 border-b flex justify-between items-center flex-shrink-0">
            <h1 class="text-xl font-bold text-gray-800">Poster Controls</h1>
            <button id="toggle-controls" class="lg:hidden p-2 rounded-md hover:bg-gray-200"><svg id="menu-icon" class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg><svg id="close-icon" class="w-6 h-6 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>
        </div>
        <div id="controls-content" class="overflow-y-auto p-4">
             <div class="mb-4 text-sm text-gray-600 bg-gray-100 p-3 rounded-md">
                <p><strong>Hint:</strong> New text auto-fits. Select to drag or resize. Hold <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-200 border border-gray-300 rounded-md">Shift</kbd> to multi-select.</p>
            </div>
            <div class="mb-4">
                <label for="text-input" class="block text-sm font-medium text-gray-700 mb-1">Text (New line for each line)</label>
                <textarea id="text-input" rows="6" class="w-full p-2 border border-gray-300 rounded-md">
RESIZE ME
*DRAG ME*
HAVE FUN
</textarea>
            </div>
            <div class="mb-4">
                <label for="margin-input" class="block text-sm font-medium text-gray-700 mb-1">Initial Margin (px)</label>
                <input type="number" id="margin-input" value="30" class="w-full p-2 border border-gray-300 rounded-md">
            </div>
            <div class="p-4 border rounded-md mb-4 bg-gray-50">
                 <h2 class="text-lg font-semibold mb-2 text-gray-700">Actions</h2>
                 <div class="space-y-2">
                     <button id="download-btn" class="btn-action"><span>Download JPEG</span></button>
                     <button id="copy-btn" class="btn-action"><span id="copy-btn-text">Copy Styles</span></button>
                 </div>
            </div>
            <div class="mb-4">
                <label for="canvas-size" class="block text-sm font-medium text-gray-700 mb-1">Canvas Size</label>
                <select id="canvas-size" class="w-full p-2 border border-gray-300 rounded-md">
                    <option value="tall">Tall (9:16)</option><option value="wide">Wide (16:9)</option><option value="square">Square (1:1)</option>
                </select>
            </div>
            <div class="mb-4">
                <label for="bg-color" class="block text-sm font-medium text-gray-700 mb-1">Background Color</label>
                <input type="color" id="bg-color" value="#00008B" class="w-full h-10 p-1 border border-gray-300 rounded-md">
            </div>
            <div class="p-4 border rounded-md mb-4 bg-gray-50">
                <h2 class="text-lg font-semibold mb-2 text-gray-700">Primary Font</h2>
                <select id="primary-font" class="w-full p-2 border border-gray-300 rounded-md mb-2"></select>
                <input type="color" id="primary-color" value="#FFFFFF" class="w-full h-10 p-1 border border-gray-300 rounded-md mb-2">
                <div class="flex items-center space-x-4"><label class="flex items-center"><input type="checkbox" id="primary-bold" class="rounded text-indigo-600"><span class="ml-2 text-sm">Bold</span></label><label class="flex items-center"><input type="checkbox" id="primary-italic" class="rounded text-indigo-600"><span class="ml-2 text-sm">Italic</span></label></div>
            </div>
            <div class="p-4 border rounded-md bg-gray-50">
                <h2 class="text-lg font-semibold mb-2 text-gray-700">Call-to-Action Font (*)</h2>
                <select id="secondary-font" class="w-full p-2 border border-gray-300 rounded-md mb-2"></select>
                <input type="color" id="secondary-color" value="#ADD8E6" class="w-full h-10 p-1 border border-gray-300 rounded-md mb-2">
                 <div class="flex items-center space-x-4"><label class="flex items-center"><input type="checkbox" id="secondary-bold" class="rounded text-indigo-600"><span class="ml-2 text-sm">Bold</span></label><label class="flex items-center"><input type="checkbox" id="secondary-italic" class="rounded text-indigo-600"><span class="ml-2 text-sm">Italic</span></label></div>
            </div>
        </div>
    </div>
    <div id="canvas-container" class="flex-grow flex items-center justify-center p-4 bg-gray-200 relative min-h-0">
        <div class="absolute top-5 right-5 z-10">
            <button id="fullscreen-btn" class="bg-white text-gray-700 px-3 py-2 rounded-md shadow-md hover:bg-gray-100 transition flex items-center gap-2">
                <svg id="fullscreen-enter-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1v4m0 0h-4m4 0l-5-5M4 16v4m0 0h4m-4 0l5-5m11 1v-4m0 0h-4m4 0l-5 5"></path></svg>
                <svg id="fullscreen-exit-icon" class="w-5 h-5 hidden" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 3h6v6m0 0l-7 7M9 21H3v-6m0 0l7-7m7 7h6v6m0 0l-7-7M9 3H3v6m0 0l7 7"></path></svg>
                <span id="fullscreen-text">Full Screen</span>
            </button>
        </div>
        <canvas id="poster-canvas" class="bg-white shadow-lg rounded-md"></canvas>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const FONT_LIST = {
                "Serif": ["Merriweather", "Lora", "Playfair Display"],
                "Sans-serif": ["Roboto", "Lato", "Montserrat", "Oswald", "Raleway"],
                "Display": ["Lobster", "Alfa Slab One", "Bebas Neue", "Pacifico", "Righteous"],
                "Handwriting": ["Indie Flower", "Patrick Hand", "Dancing Script", "Caveat"]
            };

            const canvas = document.getElementById('poster-canvas');
            const ctx = canvas.getContext('2d');
            const canvasContainer = document.getElementById('canvas-container');
            const textInput = document.getElementById('text-input');
            const marginInput = document.getElementById('margin-input');

            const controls = {
                bgColor: document.getElementById('bg-color'),
                canvasSize: document.getElementById('canvas-size'),
                primary: {font: document.getElementById('primary-font'), color: document.getElementById('primary-color'), bold: document.getElementById('primary-bold'), italic: document.getElementById('primary-italic')},
                secondary: {font: document.getElementById('secondary-font'), color: document.getElementById('secondary-color'), bold: document.getElementById('secondary-bold'), italic: document.getElementById('secondary-italic')}
            };
            
            let textItems = [];
            let lastMousePos = { x: 0, y: 0 };
            const RESIZE_HANDLE_SIZE = 20;
            const sizes = { tall: { width: 1080, height: 1920 }, wide: { width: 1920, height: 1080 }, square: { width: 1080, height: 1080 } };

            function populateFontSelectors() {
                const selects = [controls.primary.font, controls.secondary.font];
                selects.forEach(select => {
                    select.innerHTML = '';
                    for (const category in FONT_LIST) {
                        const optgroup = document.createElement('optgroup');
                        optgroup.label = category;
                        FONT_LIST[category].forEach(fontName => {
                            const option = document.createElement('option');
                            option.value = fontName;
                            option.textContent = fontName;
                            option.style.fontFamily = `'${fontName}', sans-serif`;
                            option.style.fontSize = '16px';
                            optgroup.appendChild(option);
                        });
                        select.appendChild(optgroup);
                    }
                });
                 controls.primary.font.value = 'Roboto';
                 controls.secondary.font.value = 'Lobster';
            }

            async function loadFonts() {
                const loadingOverlay = document.getElementById('loading-overlay');
                loadingOverlay.style.display = 'flex';
                const fontPromises = [];
                for (const category in FONT_LIST) {
                    FONT_LIST[category].forEach(font => {
                        fontPromises.push(document.fonts.load(`1em "${font}"`));
                    });
                }
                try {
                    await Promise.all(fontPromises);
                } catch (err) {
                    console.error("Error loading fonts:", err);
                } finally {
                    loadingOverlay.style.display = 'none';
                    init();
                }
            }

            function getFontString(item) { return `${item.italic ? 'italic' : ''} ${item.bold ? 'bold' : ''} ${item.fontSize}px "${item.fontFamily}"`; }
            function getFitFontSize(text, item) {
                const margin = parseInt(marginInput.value, 10) || 0;
                const targetWidth = canvas.width - (2 * margin);
                let fontSize = 300;
                if (!text.trim()) return 10;
                do {
                    fontSize -= 5;
                    ctx.font = `${item.italic ? 'italic' : ''} ${item.bold ? 'bold' : ''} ${fontSize}px "${item.fontFamily}"`;
                } while (ctx.measureText(text).width > targetWidth && fontSize > 10);
                return fontSize;
            }

            function syncTextItems() {
                const lines = textInput.value.split('\n');
                const newTextItems = [];
                let totalHeight = 0;

                // First pass: Create items and calculate their height
                lines.forEach(line => {
                    const isSecondary = line.startsWith('*') && line.endsWith('*');
                    const props = isSecondary ? controls.secondary : controls.primary;
                    const newItem = {
                        originalLine: line,
                        text: isSecondary ? line.substring(1, line.length - 1) : line,
                        isSecondary: isSecondary,
                        fontFamily: props.font.value,
                        color: props.color.value,
                        bold: props.bold.checked,
                        italic: props.italic.checked,
                        x: canvas.width / 2,
                        y: 0, // temp y
                        isSelected: false,
                        action: null,
                    };
                    newItem.fontSize = getFitFontSize(newItem.text, newItem);
                    
                    // Estimate height for stacking
                    ctx.font = getFontString(newItem);
                    newItem.height = newItem.fontSize * 1.2; // A common line-height approximation
                    totalHeight += newItem.height;
                    newTextItems.push(newItem);
                });

                // Second pass: Position items vertically
                let currentY = (canvas.height - totalHeight) / 2;
                if (currentY < 50) { // Add some padding if it's too high
                    currentY = 50;
                }

                newTextItems.forEach(item => {
                    item.y = currentY + item.height / 2;
                    currentY += item.height;
                });

                textItems = newTextItems;
                draw();
            }

            function draw(isExporting = false) {
                ctx.fillStyle = controls.bgColor.value;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                textItems.forEach(item => {
                    ctx.font = getFontString(item);
                    const metrics = ctx.measureText(item.text);
                    item.width = metrics.width;
                    item.actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
                    ctx.fillStyle = item.color;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.text, item.x, item.y);
                    if (item.isSelected && !isExporting) drawSelectionBox(item);
                });
            }
            
            function drawSelectionBox(item) {
                const tL = { x: item.x - item.width / 2, y: item.y - item.actualHeight / 2 };
                const bR = { x: item.x + item.width / 2, y: item.y + item.actualHeight / 2 };
                ctx.strokeStyle = '#4A90E2';
                ctx.lineWidth = 4;
                ctx.strokeRect(tL.x - 5, tL.y - 5, bR.x - tL.x + 10, bR.y - tL.y + 10);
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(bR.x + 5, bR.y + 5, RESIZE_HANDLE_SIZE / 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
            }

            function resizeCanvas() {
                const size = sizes[controls.canvasSize.value];
                const container = canvasContainer;
                const isFullscreen = !!document.fullscreenElement;
                const containerW = isFullscreen ? window.innerWidth : container.clientWidth;
                const containerH = isFullscreen ? window.innerHeight : container.clientHeight;
                const ratio = containerW / containerH > size.width / size.height;
                canvas.style.height = (ratio ? containerH : containerW / (size.width / size.height)) * 0.9 + 'px';
                canvas.style.width = (ratio ? containerH * (size.width / size.height) : containerW) * 0.9 + 'px';
                canvas.width = size.width;
                canvas.height = size.height;
                syncTextItems();
            }

            const getCanvasPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {x: (clientX - rect.left) * (canvas.width / rect.width), y: (clientY - rect.top) * (canvas.height / rect.height)};
            };
            
            function getActionTarget(p) {
                for (const item of [...textItems].reverse()) {
                    if (item.isSelected) {
                        const bR = { x: item.x + item.width / 2, y: item.y + item.actualHeight / 2 };
                        if (Math.sqrt(Math.pow(p.x - (bR.x + 5), 2) + Math.pow(p.y - (bR.y + 5), 2)) < RESIZE_HANDLE_SIZE) return { item, action: 'resizing' };
                    }
                }
                for (const item of [...textItems].reverse()) {
                    if (p.x > item.x - item.width/2 && p.x < item.x + item.width/2 && p.y > item.y - item.actualHeight/2 && p.y < item.y + item.actualHeight/2) return { item, action: 'dragging' };
                }
                return null;
            }

            function handleMouseDown(e) {
                e.preventDefault();
                const pos = getCanvasPos(e);
                lastMousePos = pos;
                const target = getActionTarget(pos);

                if (target) {
                    if (!e.shiftKey && !target.item.isSelected) textItems.forEach(i => i.isSelected = false);
                    target.item.isSelected = true;
                    textItems.forEach(i => {
                        if (i.isSelected) {
                            i.action = target.action;
                            i.dragOffset = { x: pos.x - i.x, y: pos.y - i.y };
                            i.dragStart = { fontSize: i.fontSize, width: i.width, height: i.actualHeight };
                            i.topLeftStart = { x: i.x - i.width/2, y: i.y - i.actualHeight/2 };
                        }
                    });
                } else {
                    textItems.forEach(i => i.isSelected = false);
                }
                draw();
            }

            function handleMouseMove(e) {
                e.preventDefault();
                const pos = getCanvasPos(e);
                let needsRedraw = false;
                const selectedItems = textItems.filter(i => i.isSelected && i.action);
                if (selectedItems.length === 0) return;

                if (selectedItems[0].action === 'dragging') {
                    selectedItems.forEach(item => {
                        const newX = pos.x - item.dragOffset.x;
                        const newY = pos.y - item.dragOffset.y;
                        const halfW = item.width / 2;
                        const halfH = item.actualHeight / 2;
                        item.x = Math.max(halfW, Math.min(canvas.width - halfW, newX));
                        item.y = Math.max(halfH, Math.min(canvas.height - halfH, newY));
                    });
                    needsRedraw = true;
                } else if (selectedItems[0].action === 'resizing') {
                    const resizingItem = selectedItems.find(i => i.action === 'resizing');
                    const dx = pos.x - lastMousePos.x;
                    const newWidth = Math.max(20, resizingItem.width + dx);
                    const scale = newWidth / resizingItem.width;
                    
                    selectedItems.forEach(item => {
                        item.fontSize = item.dragStart.fontSize * scale;
                        const newW = item.dragStart.width * scale;
                        const newH = item.dragStart.height * scale;
                        item.x = item.topLeftStart.x + newW/2;
                        item.y = item.topLeftStart.y + newH/2;
                    });
                    needsRedraw = true;
                }
                if (needsRedraw) draw();
            }

            function applyStyleToSelection() {
                const selected = textItems.filter(i => i.isSelected);
                selected.forEach(item => {
                     const props = item.isSecondary ? controls.secondary : controls.primary;
                     item.fontFamily = props.font.value;
                     item.color = props.color.value;
                     item.bold = props.bold.checked;
                     item.italic = props.italic.checked;
                });
                if(selected.length > 0) draw();
            }
            
            function init() {
                populateFontSelectors();
                resizeCanvas();
                textInput.addEventListener('input', syncTextItems);
                marginInput.addEventListener('change', syncTextItems);
                controls.bgColor.addEventListener('input', draw);
                controls.canvasSize.addEventListener('change', resizeCanvas);
                Object.values(controls.primary).forEach(el => el.addEventListener('input', applyStyleToSelection));
                Object.values(controls.secondary).forEach(el => el.addEventListener('input', applyStyleToSelection));
                window.addEventListener('resize', resizeCanvas);
                canvas.addEventListener('mousedown', handleMouseDown);
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseup', () => textItems.forEach(i=>i.action=null));
                canvas.addEventListener('mouseleave', () => textItems.forEach(i=>i.action=null));
                canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
                canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
                canvas.addEventListener('touchend', () => textItems.forEach(i=>i.action=null));
            }
            loadFonts();
        });
    </script>
</body>
</html>
