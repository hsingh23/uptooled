<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Dictation & Note Polishing App | Powered by Gemini</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Transform your voice recordings into perfectly transcribed and polished notes with our AI-powered Dictation App. Effortlessly capture ideas, meetings, and lectures using Gemini technology. Get clean, organized text in minutes." />
    <meta name="keywords" content="dictation app, voice notes, AI transcription, Gemini API, voice to text, audio recording, note taking, polished notes, smart notes, meeting transcription, lecture capture, productivity tool, voice recognition" />
    <meta name="robots" content="index, follow" />
    <meta name="author" content="Gemini-Powered App" />

    <!-- Open Graph / Facebook Meta Tags -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="/" /> <!-- Adjust to the full URL when deployed -->
    <meta property="og:title" content="AI Dictation & Note Polishing App | Gemini Powered" />
    <meta property="og:description" content="Transform voice recordings into perfectly transcribed and polished notes with our AI-powered Dictation App using Gemini." />
    <meta property="og:site_name" content="Dictation App" />

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <!-- <meta name="twitter:site" content="@YourTwitterHandle" /> -->
    <meta name="twitter:title" content="AI Dictation & Note Polishing App | Gemini Powered" />
    <meta name="twitter:description" content="Transform voice recordings into perfectly transcribed and polished notes with our AI-powered Dictation App using Gemini." />
    <!-- <meta name="twitter:image" content="URL_TO_YOUR_PREVIEW_IMAGE_1200x600.png" /> -->

    <!-- Theme Color for Browser UI -->
    <meta name="theme-color" content="#121212" media="(prefers-color-scheme: dark)">
    <meta name="theme-color" content="#F7F7F7" media="(prefers-color-scheme: light)">


    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/genai@^0.8.0",
          "marked": "https://esm.sh/marked@^4.0.0"
        }
      }
    </script>
    <style>
      @import url(https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css);
      @import url(https://fonts.cdnfonts.com/css/sf-mono);

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      :root {
        --color-bg-dark: #121212;
        --color-bg-alt-dark: #1E1E1E;
        --color-surface-dark: rgba(255, 255, 255, 0.05);
        --color-surface-hover-dark: rgba(255, 255, 255, 0.08);
        --color-surface-active-dark: rgba(255, 255, 255, 0.12);
        --color-text-dark: #E1E1E1;
        --color-text-secondary-dark: #A8A8A8;
        --color-text-tertiary-dark: #7F7F7F;
        --color-accent-dark: #82aaff;
        --color-accent-alt-dark: #c792ea;
        --color-cursor-dark: var(--color-accent-dark);
        --color-border-dark: rgba(255, 255, 255, 0.12);
        --color-recording-dark: #ff453a;
        --color-success-dark: #32d74b;

        --glass-bg-dark: rgba(30, 30, 30, 0.6);
        --glass-border-dark: rgba(255, 255, 255, 0.15);
        --glass-highlight-dark: rgba(255, 255, 255, 0.1);
        --glass-shadow-dark: rgba(0, 0, 0, 0.3);

        --glass-recording-bg-dark: rgba(28, 28, 30, 0.75);
        --glass-recording-border-dark: rgba(255, 255, 255, 0.15);

        --color-bg-light: #F7F7F7;
        --color-bg-alt-light: #EDEDED;
        --color-surface-light: #FFFFFF;
        --color-surface-hover-light: #F0F0F0;
        --color-surface-active-light: #EAEAEA;
        --color-text-light: #333333;
        --color-text-secondary-light: #666666;
        --color-text-tertiary-light: #999999;
        --color-accent-light: #007AFF;
        --color-accent-alt-light: #5856d6;
        --color-cursor-light: var(--color-accent-light);
        --color-border-light: #DCDCDC;
        --color-recording-light: #ff3b30;
        --color-success-light: #30d158;

        --glass-bg-light: rgba(255, 255, 255, 0.65);
        --glass-border-light: rgba(0, 0, 0, 0.07);
        --glass-highlight-light: var(--color-surface-active-light);
        --glass-shadow-light: rgba(0, 0, 0, 0.05);

        --glass-recording-bg-light: rgba(248, 248, 248, 0.75);
        --glass-recording-border-light: rgba(0, 0, 0, 0.1);

        --color-bg: var(--color-bg-dark);
        --color-bg-alt: var(--color-bg-alt-dark);
        --color-surface: var(--color-surface-dark);
        --color-surface-hover: var(--color-surface-hover-dark);
        --color-surface-active: var(--color-surface-active-dark);
        --color-text: var(--color-text-dark);
        --color-text-secondary: var(--color-text-secondary-dark);
        --color-text-tertiary: var(--color-text-tertiary-dark);
        --color-accent: var(--color-accent-dark);
        --color-accent-alt: var(--color-accent-alt-dark);
        --color-cursor: var(--color-cursor-dark);
        --color-border: var(--color-border-dark);
        --color-recording: var(--color-recording-dark);
        --color-success: var(--color-success-dark);
        --glass-bg: var(--glass-bg-dark);
        --glass-border: var(--glass-border-dark);
        --glass-highlight: var(--glass-highlight-dark);
        --glass-shadow: var(--glass-shadow-dark);
        --glass-recording-bg: var(--glass-recording-bg-dark);
        --glass-recording-border: var(--glass-recording-border-dark);

        --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.2);
        --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.3);
        --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.4);
        --transition-fast: 0.2s ease;
        --transition-normal: 0.3s ease;
        --transition-slow: 0.45s ease;
        --transition-tabs: 0.3s cubic-bezier(0.4, 0, 0.2, 1);

        --font-primary: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        --font-mono: 'SF Mono', ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;

        --footer-height: 120px; /* Height of the non-live recording interface */
        --live-footer-height: 350px; /* Height of the live recording interface when fixed */
      }

      body.light-mode {
        --color-bg: var(--color-bg-light);
        --color-bg-alt: var(--color-bg-alt-light);
        --color-surface: var(--color-surface-light);
        --color-surface-hover: var(--color-surface-hover-light);
        --color-surface-active: var(--color-surface-active-light);
        --color-text: var(--color-text-light);
        --color-text-secondary: var(--color-text-secondary-light);
        --color-text-tertiary: var(--color-text-tertiary-light);
        --color-accent: var(--color-accent-light);
        --color-accent-alt: var(--color-accent-alt-light);
        --color-cursor: var(--color-cursor-light);
        --color-border: var(--color-border-light);
        --color-recording: var(--color-recording-light);
        --color-success: var(--color-success-light);
        --glass-bg: var(--glass-bg-light);
        --glass-border: var(--glass-border-light);
        --glass-highlight: var(--glass-highlight-light);
        --glass-shadow: var(--glass-shadow-light);
        --glass-recording-bg: var(--glass-recording-bg-light);
        --glass-recording-border: var(--glass-recording-border-light);

        --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.04), 0 1px 1px rgba(0,0,0,0.03);
        --shadow-md: 0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0,0,0,0.04);
        --shadow-lg: 0 4px 8px rgba(0, 0, 0, 0.06), 0 2px 6px rgba(0,0,0,0.05);
      }

      [contenteditable] {
        caret-color: var(--color-cursor);
      }
      [contenteditable][placeholder].placeholder-active {
        color: var(--color-text-tertiary);
        opacity: 0.8;
      }

      html {
        height: 100%;
        overflow: hidden; /* Prevent global scrollbars, app is self-contained */
      }

      body {
        font-family: var(--font-primary);
        background-color: var(--color-bg);
        color: var(--color-text);
        line-height: 1.65;
        height: 100vh; /* Fixed viewport height */
        overflow: hidden; /* Prevent body scrollbars */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        letter-spacing: -0.01em;
        transition: background-color var(--transition-normal), color var(--transition-normal);
        margin: 0;
      }

      .app-container {
        display: flex;
        flex-direction: column;
        height: 100%; /* Fill body */
        width: 100%;
        max-width: 100%;
        overflow: hidden; /* Ensure app container doesn't scroll */
      }

      .main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        position: relative; /* For z-index context of children and :has selector behavior */
        overflow: hidden; /* Important: This clips its content if it would overflow */
        transition: padding-bottom var(--transition-slow) ease-in-out; /* Smoothly adjust padding for fixed panel */
      }

      /* When .is-live is a direct child of .main-content, add padding to .main-content */
      .main-content:has(> .recording-interface.is-live) {
        padding-bottom: var(--live-footer-height);
      }

      .note-area {
        flex: 1; /* Takes available space within main-content */
        overflow: hidden; /* For its own content scroll (note-content-wrapper) */
        display: flex;
        flex-direction: column;
        background-color: var(--color-bg);
        padding: 32px 0 0;
        transition: background-color var(--transition-normal);
        min-height: 0; /* Allows this flex item to shrink below its content size if needed */
      }

      .note-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 40px 16px;
        border-bottom: 1px solid var(--color-border);
        margin-bottom: 12px;
        transition: border-color var(--transition-normal);
      }

      .editor-title {
        font-size: 22px;
        font-weight: 600;
        outline: none;
        border: none;
        padding: 0;
        margin: 0;
        flex-grow: 1;
        margin-right: 24px;
        color: var(--color-text);
        font-family: var(--font-primary);
        background-color: transparent;
      }

      .tab-navigation-container {
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        border-radius: 10px;
        padding: 4px;
        display: inline-flex;
        box-shadow: var(--shadow-sm);
        transition: background-color var(--transition-normal), border-color var(--transition-normal);
      }

      .tab-navigation {
        display: flex;
        position: relative;
        border-radius: 7px;
        overflow: hidden;
      }

      .tab-button {
        background: transparent;
        border: none;
        padding: 6px 16px;
        margin: 0;
        font-size: 13px;
        font-weight: 500;
        color: var(--color-text-secondary);
        border-radius: 6px;
        cursor: pointer;
        transition: color var(--transition-fast);
        position: relative;
        z-index: 1;
        flex-shrink: 0;
        font-family: var(--font-primary);
        letter-spacing: -0.01em;
      }

      .tab-button:hover {
        color: var(--color-text);
      }

      .tab-button.active {
        color: var(--color-text);
      }

      body.light-mode .tab-button {
          color: var(--color-text-secondary);
      }
      body.light-mode .tab-button:hover {
          color: var(--color-text);
      }
      body.light-mode .tab-button.active {
        color: var(--color-text);
      }

      .active-tab-indicator {
        position: absolute;
        top: 0;
        left: 0;
        width: 0;
        height: 100%;
        background-color: var(--glass-highlight);
        border-radius: 6px;
        transition: left var(--transition-tabs), width var(--transition-tabs);
        z-index: 0;
        box-shadow: 0 0.5px 1.5px rgba(0,0,0,0.04), 0 0 0 0.5px rgba(0,0,0,0.02) inset;
      }

      body.light-mode .active-tab-indicator {
        box-shadow: 0 0.5px 1.5px rgba(0,0,0,0.06), 0 0 0 0.5px rgba(0,0,0,0.03) inset;
      }

      .note-content-wrapper {
        flex: 1;
        overflow-y: auto;
        padding: 0 40px 40px;
        position: relative;
        min-height: 0;
      }

      .note-content {
        outline: none;
        min-height: 100px;
        font-size: 16px;
        line-height: 1.7;
        color: var(--color-text);
        padding: 12px 0;
        font-family: var(--font-primary);
        letter-spacing: -0.01em;

        opacity: 0;
        transform: scale(0.985) translateY(8px);
        transition: opacity var(--transition-tabs), transform var(--transition-tabs);
        display: none;
        will-change: opacity, transform;
      }

      .note-content.active {
        opacity: 1;
        transform: scale(1) translateY(0);
        display: block;
      }

      .note-content h1, .note-content h2, .note-content h3 { margin-bottom: 0.75em; margin-top: 1.25em; font-weight: 600; color: var(--color-text); }
      .note-content h1 { font-size: 1.8em; }
      .note-content h2 { font-size: 1.5em; }
      .note-content h3 { font-size: 1.25em; }
      .note-content p { margin-bottom: 1em; }
      .note-content ul, .note-content ol { margin-bottom: 1em; padding-left: 1.5em; }
      .note-content li { margin-bottom: 0.5em; }
      .note-content pre { background-color: var(--color-bg-alt); padding: 1em; border-radius: 8px; margin-bottom: 1em; font-size: 0.9em; overflow-x: auto; transition: background-color var(--transition-normal); font-family: var(--font-mono); }
      .note-content code { font-family: var(--font-mono); background-color: var(--color-bg-alt); padding: 0.2em 0.4em; border-radius: 4px; font-size: 0.9em;}
      .note-content pre code { background-color: transparent; padding: 0; border-radius: 0;}


      .recording-interface {
        /* Default state: part of the flex flow in main-content */
        height: var(--footer-height);
        width: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 12px 20px;
        background-color: transparent;
        border-top: 1px solid transparent;
        flex-shrink: 0; /* Don't shrink this element in flex layout */
        /* Transition properties for when it becomes .is-live (fixed) */
        transition: opacity 0.3s ease-out, transform 0.35s ease-out,
                    background-color var(--transition-slow) ease-in-out, /* For bg change */
                    height var(--transition-slow) ease-in-out; /* If height changes for fixed */
        z-index: 10; /* Base z-index, lower than live state */
      }

      .recording-interface.is-live {
        position: fixed; /* Take out of flow, overlay */
        bottom: 0;
        left: 0;
        right: 0;
        height: var(--live-footer-height); /* Explicit height for the fixed panel */
        z-index: 1000; /* High z-index to be on top */

        /* Visuals for live state */
        background-color: var(--glass-recording-bg);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-top: 1px solid var(--glass-recording-border);
        box-shadow: 0 -4px 20px var(--glass-shadow);

        /* Internal layout */
        justify-content: flex-start; /* Align live content to top */
        padding-top: 20px; /* Internal padding from top of the fixed panel */
        padding-bottom: 20px; /* Internal padding from bottom of the fixed panel - CRITICAL for button */
        
        /* Override transform and opacity for entry animation if desired, otherwise let content appear */
        /* transform: translateY(0); */ /* Example for slide-up, needs initial state too */
        /* opacity: 1; */
      }

      .status-indicator { margin-bottom: 16px; }
      /* When live, the status indicator related to non-live state is hidden */
      .recording-interface.is-live .status-indicator { display: none; }
      .status-text { font-size: 14px; color: var(--color-text-tertiary); text-align: center; transition: color var(--transition-normal); font-family: var(--font-primary); }

      /* Elements specific to the live recording view */
      .live-recording-title,
      #liveWaveformCanvas,
      .live-recording-timer {
        opacity: 0;
        transform: translateY(15px);
        transition: opacity 0.3s ease-out 0.1s, transform 0.35s ease-out 0.1s;
      }

      .recording-interface.is-live .live-recording-title,
      .recording-interface.is-live #liveWaveformCanvas,
      .recording-interface.is-live .live-recording-timer {
        opacity: 1;
        transform: translateY(0);
      }

      .live-recording-title {
        font-size: 17px;
        color: var(--color-text);
        margin-bottom: 12px;
        text-align: center;
        font-weight: 500;
        font-family: var(--font-primary);
      }

      #liveWaveformCanvas {
        width: 100%;
        max-width: 340px;
        height: 70px;
        margin-bottom: 18px;
        border-radius: 4px;
      }

      .live-recording-timer {
        font-family: var(--font-mono);
        font-size: 44px;
        font-weight: 400;
        color: var(--color-text);
        margin-bottom: 22px;
        text-align: center;
        letter-spacing: 0.01em;
      }

      .recording-controls {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 24px;
        position: relative; /* For .record-text positioning */
        /* This container is inside .recording-interface.
           If .recording-interface.is-live has padding-bottom: 20px,
           this whole control group will be 20px from the bottom of the fixed panel. */
      }

      .action-button {
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        width: 48px; height: 48px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
        color: var(--color-text-secondary); font-size: 18px;
        cursor: pointer;
        transition: var(--transition-fast) background-color, var(--transition-fast) color, var(--transition-fast) border-color, var(--transition-fast) transform, var(--transition-fast) box-shadow;
        box-shadow: var(--shadow-sm);
        backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      }
      /* Action buttons are hidden when recording is live and panel is an overlay */
      .recording-interface.is-live .action-button { display: none; }
      .action-button:hover { color: var(--color-text); transform: translateY(-2px) scale(1.05); box-shadow: var(--shadow-md); background-color: var(--color-surface-hover); border-color: var(--glass-highlight); }

      .record-button { position: relative; width: 72px; height: 72px; border-radius: 50%; border: none; outline: none; background: none; cursor: pointer; z-index: 1; }
      .record-button-inner {
        position: relative; width: 100%; height: 100%; border-radius: 50%;
        background: var(--glass-bg);
        border: 1px solid var(--glass-border);
        display: flex; align-items: center; justify-content: center;
        color: var(--color-text); font-size: 24px; z-index: 2; box-shadow: var(--shadow-md);
        transition: all var(--transition-normal);
        backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
      }
      .record-button:hover .record-button-inner { transform: scale(1.08); background-color: var(--color-surface-hover); border-color: var(--glass-highlight); }
      .record-button.recording .record-button-inner { background-color: var(--color-recording); border: 1px solid transparent; color: white; }
      body.light-mode .record-button.recording .record-button-inner { color: white; }
      .record-button.recording:hover .record-button-inner {
          background-color: var(--color-recording);
          filter: brightness(0.9);
      }

      /* Ensure record button icon changes work in fixed panel */
      .recording-interface.is-live .record-button.recording .record-button-inner i.fa-stop { display: inline-block; font-size: 20px; }
      .recording-interface.is-live .record-button.recording .record-button-inner i.fa-microphone { display: none; }

      .record-waves { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 200px; height: 200px; z-index: 1; opacity: 0; transition: opacity var(--transition-normal); pointer-events: none; }
      .record-button.recording .record-waves { opacity: 1; }
      /* Hide waves when the panel is the fixed overlay */
      .recording-interface.is-live .record-waves { display: none; }
      .wave { fill: none; stroke: var(--color-recording); stroke-width: 1.5px; opacity: 0; transform-origin: center; }
      .record-button.recording .wave1 { animation: wave 2s infinite ease-out; }
      .record-button.recording .wave2 { animation: wave 2s infinite ease-out; animation-delay: 0.4s; }
      .record-button.recording .wave3 { animation: wave 2s infinite ease-out; animation-delay: 0.8s; }
      @keyframes wave { 0% { transform: scale(0.4); opacity: 0.8; stroke-width: 2px; } 100% { transform: scale(1.8); opacity: 0; stroke-width: 0.5px; } }

      .record-text { position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%); font-size: 12px; white-space: nowrap; color: var(--color-text-tertiary); opacity: 0; transition: opacity var(--transition-fast); font-family: var(--font-primary); }
      .record-button:hover .record-text { opacity: 1; }
      /* Hide record text hint when panel is the fixed overlay */
      .recording-interface.is-live .record-text { display: none; }

      ::-webkit-scrollbar { width: 10px; height: 10px; }
      ::-webkit-scrollbar-track { background: var(--color-bg-alt); border-radius: 5px; }
      ::-webkit-scrollbar-thumb { background: var(--glass-border); border-radius: 5px; border: 2px solid transparent; background-clip: content-box; }
      ::-webkit-scrollbar-thumb:hover { background: var(--glass-highlight); }

      .debug-panel { background-color: rgba(0, 0, 0, 0.95); color: #33ff33; font-family: var(--font-mono); font-size: 12px; padding: 12px; position: fixed; bottom: 0; left: 0; max-height: 200px; width: 100%; z-index: 2000; overflow-y: auto; display: none; }
      .debug-panel.visible { display: block; }
      .hidden { display: none !important; }

      @media (max-width: 768px) {
        .note-area { padding: 20px 0 0; }
        .note-header { padding: 0 20px 12px; flex-direction: column; align-items: stretch; gap: 12px; }
        .editor-title { padding: 0; font-size: 20px; margin-bottom: 0; margin-right: 0; text-align: left; }
        .tab-navigation-container { width: 100%; }
        .tab-navigation { width: 100%; }
        .tab-button { flex-grow: 1; text-align: center; }
        .note-content-wrapper { padding: 0 20px 20px; }
        .recording-interface.is-live { padding-left: 15px; padding-right: 15px; } /* Keep existing responsive padding */
        #liveWaveformCanvas { max-width: calc(100% - 30px); height: 60px; }
        .live-recording-timer { font-size: 36px; }
        .action-button { width: 44px; height: 44px; font-size: 16px; }
        .record-button { width: 64px; height: 64px; }
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <div class="main-content">
        <div class="note-area">
          <div class="note-header">
            <div class="editor-title" contenteditable="true" placeholder="Untitled Note">
              Untitled Note
            </div>
            <div class="tab-navigation-container">
              <div class="tab-navigation">
                <button class="tab-button active" data-tab="note">Polished</button>
                <button class="tab-button" data-tab="raw">Raw</button>
                <div class="active-tab-indicator"></div>
              </div>
            </div>
          </div>

          <div class="note-content-wrapper">
            <div
              id="polishedNote"
              class="note-content active"
              contenteditable="true"
              placeholder="Your polished notes will appear here..."
            ></div>
            <div
              id="rawTranscription"
              class="note-content"
              contenteditable="true"
              placeholder="Raw transcription will appear here..."
            ></div>
          </div>
        </div>

        <div class="recording-interface">
          <div id="liveRecordingTitle" class="live-recording-title" style="display: none">
            Recording
          </div>
          <canvas id="liveWaveformCanvas" style="display: none"></canvas>
          <div id="liveRecordingTimerDisplay" class="live-recording-timer" style="display: none">
            00:00.00
          </div>

          <div class="status-indicator">
            <span id="recordingStatus" class="status-text">Ready to record</span>
          </div>

          <div class="recording-controls">
            <button class="action-button" id="themeToggleButton" title="Toggle Theme">
              <i class="fas fa-sun"></i>
            </button>

            <button id="recordButton" class="record-button" title="Start/Stop Recording">
              <div class="record-button-inner">
                <i class="fas fa-microphone"></i>
              </div>
              <svg class="record-waves" viewBox="0 0 200 200">
                <circle class="wave wave1" cx="100" cy="100" r="40" />
                <circle class="wave wave2" cx="100" cy="100" r="70" />
                <circle class="wave wave3" cx="100" cy="100" r="100" />
              </svg>
              <span class="record-text">Record</span>
            </button>

            <button class="action-button" id="newButton" title="New Note / Clear">
              <i class="fas fa-file"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <div id="micStatus" class="debug-panel"></div>

    <script type="module">
      /**
       * @license
       * SPDX-License-Identifier: Apache-2.0
      */
      /* tslint:disable */

      import {GoogleGenAI} from '@google/genai';
      import {marked} from 'marked';

      const MODEL_NAME = 'gemini-2.5-flash-preview-04-17';

      class VoiceNotesApp {
        constructor() {
          this.genAI = new GoogleGenAI({
            apiKey: process.env.API_KEY,
          });

          this.mediaRecorder = null;
          this.audioChunks = [];
          this.isRecording = false;
          this.currentNote = null;
          this.stream = null;

          this.liveWaveformCtx = null;
          this.audioContext = null;
          this.analyserNode = null;
          this.waveformDataArray = null;
          this.waveformDrawingId = null;
          this.timerIntervalId = null;
          this.recordingStartTime = 0;

          this.recordButton = document.getElementById(
            'recordButton',
          );
          this.recordingStatus = document.getElementById(
            'recordingStatus',
          );
          this.rawTranscription = document.getElementById(
            'rawTranscription',
          );
          this.polishedNote = document.getElementById(
            'polishedNote',
          );
          this.newButton = document.getElementById('newButton');
          this.themeToggleButton = document.getElementById(
            'themeToggleButton',
          );
          this.themeToggleIcon = this.themeToggleButton.querySelector(
            'i',
          );
          this.editorTitle = document.querySelector(
            '.editor-title',
          );

          this.recordingInterface = document.querySelector(
            '.recording-interface',
          );
          this.liveRecordingTitle = document.getElementById(
            'liveRecordingTitle',
          );
          this.liveWaveformCanvas = document.getElementById(
            'liveWaveformCanvas',
          );
          this.liveRecordingTimerDisplay = document.getElementById(
            'liveRecordingTimerDisplay',
          );

          if (this.liveWaveformCanvas) {
            this.liveWaveformCtx = this.liveWaveformCanvas.getContext('2d');
          } else {
            console.warn(
              'Live waveform canvas element not found. Visualizer will not work.',
            );
          }

          if (this.recordingInterface) {
            this.statusIndicatorDiv = this.recordingInterface.querySelector(
              '.status-indicator',
            );
          } else {
            console.warn('Recording interface element not found.');
            this.statusIndicatorDiv = null;
          }

          this.bindEventListeners();
          this.initTheme();
          this.createNewNote();

          this.recordingStatus.textContent = 'Ready to record';
        }

        bindEventListeners() {
          this.recordButton.addEventListener('click', () => this.toggleRecording());
          this.newButton.addEventListener('click', () => this.createNewNote());
          this.themeToggleButton.addEventListener('click', () => this.toggleTheme());
          window.addEventListener('resize', this.handleResize.bind(this));
        }

        handleResize() {
          if (
            this.isRecording &&
            this.liveWaveformCanvas &&
            this.liveWaveformCanvas.style.display === 'block'
          ) {
            requestAnimationFrame(() => {
              this.setupCanvasDimensions();
            });
          }
        }

        setupCanvasDimensions() {
          if (!this.liveWaveformCanvas || !this.liveWaveformCtx) return;

          const canvas = this.liveWaveformCanvas;
          const dpr = window.devicePixelRatio || 1;

          const rect = canvas.getBoundingClientRect();
          const cssWidth = rect.width;
          const cssHeight = rect.height;

          canvas.width = Math.round(cssWidth * dpr);
          canvas.height = Math.round(cssHeight * dpr);

          this.liveWaveformCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        initTheme() {
          const savedTheme = localStorage.getItem('theme');
          if (savedTheme === 'light') {
            document.body.classList.add('light-mode');
            this.themeToggleIcon.classList.remove('fa-sun');
            this.themeToggleIcon.classList.add('fa-moon');
          } else {
            document.body.classList.remove('light-mode');
            this.themeToggleIcon.classList.remove('fa-moon');
            this.themeToggleIcon.classList.add('fa-sun');
          }
           // Apply theme color based on the actual theme
          const currentTheme = document.body.classList.contains('light-mode') ? 'light' : 'dark';
          const themeColorMetaDark = document.querySelector('meta[name="theme-color"][media="(prefers-color-scheme: dark)"]');
          const themeColorMetaLight = document.querySelector('meta[name="theme-color"][media="(prefers-color-scheme: light)"]');
          
          if (currentTheme === 'light') {
            if (themeColorMetaLight) themeColorMetaLight.setAttribute('media', 'all');
            if (themeColorMetaDark) themeColorMetaDark.setAttribute('media', '(prefers-color-scheme: dark)');
          } else {
            if (themeColorMetaDark) themeColorMetaDark.setAttribute('media', 'all');
            if (themeColorMetaLight) themeColorMetaLight.setAttribute('media', '(prefers-color-scheme: light)');
          }
        }

        toggleTheme() {
          document.body.classList.toggle('light-mode');
          let newTheme;
          if (document.body.classList.contains('light-mode')) {
            localStorage.setItem('theme', 'light');
            this.themeToggleIcon.classList.remove('fa-sun');
            this.themeToggleIcon.classList.add('fa-moon');
            newTheme = 'light';
          } else {
            localStorage.setItem('theme', 'dark');
            this.themeToggleIcon.classList.remove('fa-moon');
            this.themeToggleIcon.classList.add('fa-sun');
            newTheme = 'dark';
          }
          // Update theme-color meta tags dynamically
          const themeColorMetaDark = document.querySelector('meta[name="theme-color"][media*="dark"]');
          const themeColorMetaLight = document.querySelector('meta[name="theme-color"][media*="light"]');

          if (newTheme === 'light') {
            if (themeColorMetaLight) themeColorMetaLight.setAttribute('media', 'all');
            if (themeColorMetaDark) themeColorMetaDark.setAttribute('media', '(prefers-color-scheme: dark)');
          } else {
            if (themeColorMetaDark) themeColorMetaDark.setAttribute('media', 'all');
            if (themeColorMetaLight) themeColorMetaLight.setAttribute('media', '(prefers-color-scheme: light)');
          }
        }

        async toggleRecording() {
          if (!this.isRecording) {
            await this.startRecording();
          } else {
            await this.stopRecording();
          }
        }

        setupAudioVisualizer() {
          if (!this.stream || this.audioContext) return;

          this.audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          const source = this.audioContext.createMediaStreamSource(this.stream);
          this.analyserNode = this.audioContext.createAnalyser();

          this.analyserNode.fftSize = 256;
          this.analyserNode.smoothingTimeConstant = 0.75;

          const bufferLength = this.analyserNode.frequencyBinCount;
          this.waveformDataArray = new Uint8Array(bufferLength);

          source.connect(this.analyserNode);
        }

        drawLiveWaveform() {
          if (
            !this.analyserNode ||
            !this.waveformDataArray ||
            !this.liveWaveformCtx ||
            !this.liveWaveformCanvas ||
            !this.isRecording
          ) {
            if (this.waveformDrawingId) cancelAnimationFrame(this.waveformDrawingId);
            this.waveformDrawingId = null;
            return;
          }

          this.waveformDrawingId = requestAnimationFrame(() =>
            this.drawLiveWaveform(),
          );
          this.analyserNode.getByteFrequencyData(this.waveformDataArray);

          const ctx = this.liveWaveformCtx;
          const canvas = this.liveWaveformCanvas;

          const logicalWidth = canvas.clientWidth;
          const logicalHeight = canvas.clientHeight;

          ctx.clearRect(0, 0, logicalWidth, logicalHeight);

          const bufferLength = this.analyserNode.frequencyBinCount;
          const numBars = Math.floor(bufferLength * 0.5);

          if (numBars === 0) return;

          const totalBarPlusSpacingWidth = logicalWidth / numBars;
          const barWidth = Math.max(1, Math.floor(totalBarPlusSpacingWidth * 0.7));
          const barSpacing = Math.max(0, Math.floor(totalBarPlusSpacingWidth * 0.3));

          let x = 0;

          const recordingColor =
            getComputedStyle(document.documentElement)
              .getPropertyValue('--color-recording')
              .trim() || '#ff3b30';
          ctx.fillStyle = recordingColor;

          for (let i = 0; i < numBars; i++) {
            if (x >= logicalWidth) break;

            const dataIndex = Math.floor(i * (bufferLength / numBars));
            const barHeightNormalized = this.waveformDataArray[dataIndex] / 255.0;
            let barHeight = barHeightNormalized * logicalHeight;

            if (barHeight < 1 && barHeight > 0) barHeight = 1;
            barHeight = Math.round(barHeight);

            const y = Math.round((logicalHeight - barHeight) / 2);

            ctx.fillRect(Math.floor(x), y, barWidth, barHeight);
            x += barWidth + barSpacing;
          }
        }

        updateLiveTimer() {
          if (!this.isRecording || !this.liveRecordingTimerDisplay) return;
          const now = Date.now();
          const elapsedMs = now - this.recordingStartTime;

          const totalSeconds = Math.floor(elapsedMs / 1000);
          const minutes = Math.floor(totalSeconds / 60);
          const seconds = totalSeconds % 60;
          const hundredths = Math.floor((elapsedMs % 1000) / 10);

          this.liveRecordingTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(hundredths).padStart(2, '0')}`;
        }

        startLiveDisplay() {
          if (
            !this.recordingInterface ||
            !this.liveRecordingTitle ||
            !this.liveWaveformCanvas ||
            !this.liveRecordingTimerDisplay
          ) {
            console.warn(
              'One or more live display elements are missing. Cannot start live display.',
            );
            return;
          }

          this.recordingInterface.classList.add('is-live');
          this.liveRecordingTitle.style.display = 'block';
          this.liveWaveformCanvas.style.display = 'block';
          this.liveRecordingTimerDisplay.style.display = 'block';

          this.setupCanvasDimensions();

          if (this.statusIndicatorDiv) this.statusIndicatorDiv.style.display = 'none';

          const iconElement = this.recordButton.querySelector(
            '.record-button-inner i',
          );
          if (iconElement) {
            iconElement.classList.remove('fa-microphone');
            iconElement.classList.add('fa-stop');
          }

          const currentTitle = this.editorTitle.textContent?.trim();
          const placeholder =
            this.editorTitle.getAttribute('placeholder') || 'Untitled Note';
          this.liveRecordingTitle.textContent =
            currentTitle && currentTitle !== placeholder
              ? currentTitle
              : 'New Recording';

          this.setupAudioVisualizer();
          this.drawLiveWaveform();

          this.recordingStartTime = Date.now();
          this.updateLiveTimer();
          if (this.timerIntervalId) clearInterval(this.timerIntervalId);
          this.timerIntervalId = window.setInterval(() => this.updateLiveTimer(), 50);
        }

        stopLiveDisplay() {
          if (
            !this.recordingInterface ||
            !this.liveRecordingTitle ||
            !this.liveWaveformCanvas ||
            !this.liveRecordingTimerDisplay
          ) {
            if (this.recordingInterface)
              this.recordingInterface.classList.remove('is-live');
            return;
          }
          this.recordingInterface.classList.remove('is-live');
          this.liveRecordingTitle.style.display = 'none';
          this.liveWaveformCanvas.style.display = 'none';
          this.liveRecordingTimerDisplay.style.display = 'none';

          if (this.statusIndicatorDiv)
            this.statusIndicatorDiv.style.display = 'block';

          const iconElement = this.recordButton.querySelector(
            '.record-button-inner i',
          );
          if (iconElement) {
            iconElement.classList.remove('fa-stop');
            iconElement.classList.add('fa-microphone');
          }

          if (this.waveformDrawingId) {
            cancelAnimationFrame(this.waveformDrawingId);
            this.waveformDrawingId = null;
          }
          if (this.timerIntervalId) {
            clearInterval(this.timerIntervalId);
            this.timerIntervalId = null;
          }
          if (this.liveWaveformCtx && this.liveWaveformCanvas) {
            this.liveWaveformCtx.clearRect(
              0,
              0,
              this.liveWaveformCanvas.width,
              this.liveWaveformCanvas.height,
            );
          }

          if (this.audioContext) {
            if (this.audioContext.state !== 'closed') {
              this.audioContext
                .close()
                .catch((e) => console.warn('Error closing audio context', e));
            }
            this.audioContext = null;
          }
          this.analyserNode = null;
          this.waveformDataArray = null;
        }

        async startRecording() {
          try {
            this.audioChunks = [];
            if (this.stream) {
              this.stream.getTracks().forEach((track) => track.stop());
              this.stream = null;
            }
            if (this.audioContext && this.audioContext.state !== 'closed') {
              await this.audioContext.close();
              this.audioContext = null;
            }

            this.recordingStatus.textContent = 'Requesting microphone access...';

            try {
              this.stream = await navigator.mediaDevices.getUserMedia({audio: true});
            } catch (err) {
              console.error('Failed with basic constraints:', err);
              this.stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                  echoCancellation: false,
                  noiseSuppression: false,
                  autoGainControl: false,
                },
              });
            }

            try {
              this.mediaRecorder = new MediaRecorder(this.stream, {
                mimeType: 'audio/webm',
              });
            } catch (e) {
              console.error('audio/webm not supported, trying default:', e);
              this.mediaRecorder = new MediaRecorder(this.stream);
            }

            this.mediaRecorder.ondataavailable = (event) => {
              if (event.data && event.data.size > 0)
                this.audioChunks.push(event.data);
            };

            this.mediaRecorder.onstop = () => {
              this.stopLiveDisplay();

              if (this.audioChunks.length > 0) {
                const audioBlob = new Blob(this.audioChunks, {
                  type: this.mediaRecorder?.mimeType || 'audio/webm',
                });
                this.processAudio(audioBlob).catch((err) => {
                  console.error('Error processing audio:', err);
                  this.recordingStatus.textContent = 'Error processing recording';
                });
              } else {
                this.recordingStatus.textContent =
                  'No audio data captured. Please try again.';
              }

              if (this.stream) {
                this.stream.getTracks().forEach((track) => {
                  track.stop();
                });
                this.stream = null;
              }
            };

            this.mediaRecorder.start();
            this.isRecording = true;

            this.recordButton.classList.add('recording');
            this.recordButton.setAttribute('title', 'Stop Recording');

            this.startLiveDisplay();
          } catch (error) {
            console.error('Error starting recording:', error);
            const errorMessage =
              error instanceof Error ? error.message : String(error);
            const errorName = error instanceof Error ? error.name : 'Unknown';

            if (
              errorName === 'NotAllowedError' ||
              errorName === 'PermissionDeniedError'
            ) {
              this.recordingStatus.textContent =
                'Microphone permission denied. Please check browser settings and reload page.';
            } else if (
              errorName === 'NotFoundError' ||
              (errorName === 'DOMException' &&
                errorMessage.includes('Requested device not found'))
            ) {
              this.recordingStatus.textContent =
                'No microphone found. Please connect a microphone.';
            } else if (
              errorName === 'NotReadableError' ||
              errorName === 'AbortError' ||
              (errorName === 'DOMException' &&
                errorMessage.includes('Failed to allocate audiosource'))
            ) {
              this.recordingStatus.textContent =
                'Cannot access microphone. It may be in use by another application.';
            } else {
              this.recordingStatus.textContent = `Error: ${errorMessage}`;
            }

            this.isRecording = false;
            if (this.stream) {
              this.stream.getTracks().forEach((track) => track.stop());
              this.stream = null;
            }
            this.recordButton.classList.remove('recording');
            this.recordButton.setAttribute('title', 'Start Recording');
            this.stopLiveDisplay();
          }
        }

        async stopRecording() {
          if (this.mediaRecorder && this.isRecording) {
            try {
              this.mediaRecorder.stop();
            } catch (e) {
              console.error('Error stopping MediaRecorder:', e);
              this.stopLiveDisplay();
            }

            this.isRecording = false;

            this.recordButton.classList.remove('recording');
            this.recordButton.setAttribute('title', 'Start Recording');
            this.recordingStatus.textContent = 'Processing audio...';
          } else {
            if (!this.isRecording) this.stopLiveDisplay();
          }
        }

        async processAudio(audioBlob) {
          if (audioBlob.size === 0) {
            this.recordingStatus.textContent =
              'No audio data captured. Please try again.';
            return;
          }

          try {
            URL.createObjectURL(audioBlob);

            this.recordingStatus.textContent = 'Converting audio...';

            const reader = new FileReader();
            const readResult = new Promise((resolve, reject) => {
              reader.onloadend = () => {
                try {
                  const base64data = reader.result;
                  const base64Audio = base64data.split(',')[1];
                  resolve(base64Audio);
                } catch (err) {
                  reject(err);
                }
              };
              reader.onerror = () => reject(reader.error);
            });
            reader.readAsDataURL(audioBlob);
            const base64Audio = await readResult;

            if (!base64Audio) throw new Error('Failed to convert audio to base64');

            const mimeType = this.mediaRecorder?.mimeType || 'audio/webm';
            await this.getTranscription(base64Audio, mimeType);
          } catch (error) {
            console.error('Error in processAudio:', error);
            this.recordingStatus.textContent =
              'Error processing recording. Please try again.';
          }
        }

        async getTranscription(base64Audio, mimeType) {
          try {
            this.recordingStatus.textContent = 'Getting transcription...';

            const contents = [
              {text: 'Generate a complete, detailed transcript of this audio.'},
              {inlineData: {mimeType: mimeType, data: base64Audio}},
            ];

            const response = await this.genAI.models.generateContent({
              model: MODEL_NAME,
              contents: contents,
            });

            const transcriptionText = response.text;

            if (transcriptionText) {
              this.rawTranscription.textContent = transcriptionText;
              if (transcriptionText.trim() !== '') {
                this.rawTranscription.classList.remove('placeholder-active');
              } else {
                const placeholder =
                  this.rawTranscription.getAttribute('placeholder') || '';
                this.rawTranscription.textContent = placeholder;
                this.rawTranscription.classList.add('placeholder-active');
              }

              if (this.currentNote)
                this.currentNote.rawTranscription = transcriptionText;
              this.recordingStatus.textContent =
                'Transcription complete. Polishing note...';
              this.getPolishedNote().catch((err) => {
                console.error('Error polishing note:', err);
                this.recordingStatus.textContent =
                  'Error polishing note after transcription.';
              });
            } else {
              this.recordingStatus.textContent =
                'Transcription failed or returned empty.';
              this.polishedNote.innerHTML =
                '<p><em>Could not transcribe audio. Please try again.</em></p>';
              this.rawTranscription.textContent =
                this.rawTranscription.getAttribute('placeholder');
              this.rawTranscription.classList.add('placeholder-active');
            }
          } catch (error) {
            console.error('Error getting transcription:', error);
            this.recordingStatus.textContent =
              'Error getting transcription. Please try again.';
            this.polishedNote.innerHTML = `<p><em>Error during transcription: ${error instanceof Error ? error.message : String(error)}</em></p>`;
            this.rawTranscription.textContent =
              this.rawTranscription.getAttribute('placeholder');
            this.rawTranscription.classList.add('placeholder-active');
          }
        }

        async getPolishedNote() {
          try {
            if (
              !this.rawTranscription.textContent ||
              this.rawTranscription.textContent.trim() === '' ||
              this.rawTranscription.classList.contains('placeholder-active')
            ) {
              this.recordingStatus.textContent = 'No transcription to polish';
              this.polishedNote.innerHTML =
                '<p><em>No transcription available to polish.</em></p>';
              const placeholder = this.polishedNote.getAttribute('placeholder') || '';
              this.polishedNote.innerHTML = placeholder;
              this.polishedNote.classList.add('placeholder-active');
              return;
            }

            this.recordingStatus.textContent = 'Polishing note...';

            const prompt = `Take this raw transcription and create a polished, well-formatted note.
                          Remove filler words (um, uh, like), repetitions, and false starts.
                          Format any lists or bullet points properly. Use markdown formatting for headings, lists, etc.
                          Maintain all the original content and meaning.

                          Raw transcription:
                          ${this.rawTranscription.textContent}`;
            const contents = [{text: prompt}];

            const response = await this.genAI.models.generateContent({
              model: MODEL_NAME,
              contents: contents,
            });
            const polishedText = response.text;

            if (polishedText) {
              const htmlContent = marked.parse(polishedText);
              this.polishedNote.innerHTML = htmlContent;
              if (polishedText.trim() !== '') {
                this.polishedNote.classList.remove('placeholder-active');
              } else {
                const placeholder =
                  this.polishedNote.getAttribute('placeholder') || '';
                this.polishedNote.innerHTML = placeholder;
                this.polishedNote.classList.add('placeholder-active');
              }

              let noteTitleSet = false;
              const lines = polishedText.split('\n').map((l) => l.trim());

              for (const line of lines) {
                if (line.startsWith('#')) {
                  const title = line.replace(/^#+\s+/, '').trim();
                  if (this.editorTitle && title) {
                    this.editorTitle.textContent = title;
                    this.editorTitle.classList.remove('placeholder-active');
                    noteTitleSet = true;
                    break;
                  }
                }
              }

              if (!noteTitleSet && this.editorTitle) {
                for (const line of lines) {
                  if (line.length > 0) {
                    let potentialTitle = line.replace(
                      /^[\*_\`#\->\s\[\]\(.\d)]+/,
                      '',
                    );
                    potentialTitle = potentialTitle.replace(/[\*_\`#]+$/, '');
                    potentialTitle = potentialTitle.trim();

                    if (potentialTitle.length > 3) {
                      const maxLength = 60;
                      this.editorTitle.textContent =
                        potentialTitle.substring(0, maxLength) +
                        (potentialTitle.length > maxLength ? '...' : '');
                      this.editorTitle.classList.remove('placeholder-active');
                      noteTitleSet = true;
                      break;
                    }
                  }
                }
              }

              if (!noteTitleSet && this.editorTitle) {
                const currentEditorText = this.editorTitle.textContent?.trim();
                const placeholderText =
                  this.editorTitle.getAttribute('placeholder') || 'Untitled Note';
                if (
                  currentEditorText === '' ||
                  currentEditorText === placeholderText
                ) {
                  this.editorTitle.textContent = placeholderText;
                  if (!this.editorTitle.classList.contains('placeholder-active')) {
                    this.editorTitle.classList.add('placeholder-active');
                  }
                }
              }

              if (this.currentNote) this.currentNote.polishedNote = polishedText;
              this.recordingStatus.textContent =
                'Note polished. Ready for next recording.';
            } else {
              this.recordingStatus.textContent =
                'Polishing failed or returned empty.';
              this.polishedNote.innerHTML =
                '<p><em>Polishing returned empty. Raw transcription is available.</em></p>';
              if (
                this.polishedNote.textContent?.trim() === '' ||
                this.polishedNote.innerHTML.includes('<em>Polishing returned empty')
              ) {
                const placeholder =
                  this.polishedNote.getAttribute('placeholder') || '';
                this.polishedNote.innerHTML = placeholder;
                this.polishedNote.classList.add('placeholder-active');
              }
            }
          } catch (error) {
            console.error('Error polishing note:', error);
            this.recordingStatus.textContent =
              'Error polishing note. Please try again.';
            this.polishedNote.innerHTML = `<p><em>Error during polishing: ${error instanceof Error ? error.message : String(error)}</em></p>`;
            if (
              this.polishedNote.textContent?.trim() === '' ||
              this.polishedNote.innerHTML.includes('<em>Error during polishing')
            ) {
              const placeholder = this.polishedNote.getAttribute('placeholder') || '';
              this.polishedNote.innerHTML = placeholder;
              this.polishedNote.classList.add('placeholder-active');
            }
          }
        }

        createNewNote() {
          this.currentNote = {
            id: `note_${Date.now()}`,
            rawTranscription: '',
            polishedNote: '',
            timestamp: Date.now(),
          };

          const rawPlaceholder =
            this.rawTranscription.getAttribute('placeholder') || '';
          this.rawTranscription.textContent = rawPlaceholder;
          this.rawTranscription.classList.add('placeholder-active');

          const polishedPlaceholder =
            this.polishedNote.getAttribute('placeholder') || '';
          this.polishedNote.innerHTML = polishedPlaceholder;
          this.polishedNote.classList.add('placeholder-active');

          if (this.editorTitle) {
            const placeholder =
              this.editorTitle.getAttribute('placeholder') || 'Untitled Note';
            this.editorTitle.textContent = placeholder;
            this.editorTitle.classList.add('placeholder-active');
          }
          this.recordingStatus.textContent = 'Ready to record';

          if (this.isRecording) {
            this.mediaRecorder?.stop();
            this.isRecording = false;
            this.recordButton.classList.remove('recording');
          } else {
            this.stopLiveDisplay();
          }
        }
      }

      document.addEventListener('DOMContentLoaded', () => {
        new VoiceNotesApp();

        document
          .querySelectorAll('[contenteditable][placeholder]')
          .forEach((el) => {
            const placeholder = el.getAttribute('placeholder');

            function updatePlaceholderState() {
              const currentText = (
                el.id === 'polishedNote' ? el.innerText : el.textContent
              )?.trim();

              if (currentText === '' || currentText === placeholder) {
                if (el.id === 'polishedNote' && currentText === '') {
                  el.innerHTML = placeholder;
                } else if (currentText === '') {
                  el.textContent = placeholder;
                }
                el.classList.add('placeholder-active');
              } else {
                el.classList.remove('placeholder-active');
              }
            }

            updatePlaceholderState();

            el.addEventListener('focus', function () {
              const currentText = (
                this.id === 'polishedNote' ? this.innerText : this.textContent
              )?.trim();
              if (currentText === placeholder) {
                if (this.id === 'polishedNote') this.innerHTML = '';
                else this.textContent = '';
                this.classList.remove('placeholder-active');
              }
            });

            el.addEventListener('blur', function () {
              updatePlaceholderState();
            });
          });
      });
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const tabNav = document.querySelector(".tab-navigation");
        const tabButtons = tabNav.querySelectorAll(".tab-button");
        const activeTabIndicator = tabNav.querySelector(".active-tab-indicator");
        const noteContents = document.querySelectorAll(".note-content");

        function setActiveTab(activeButton, skipAnimation = false) {
          if (!activeButton || !activeTabIndicator) return;

          tabButtons.forEach((btn) => btn.classList.remove("active"));
          activeButton.classList.add("active");

          const tabName = activeButton.getAttribute("data-tab");
          noteContents.forEach((content) => content.classList.remove("active"));

          if (tabName === "raw") {
            document.getElementById("rawTranscription").classList.add("active");
          } else {
            document.getElementById("polishedNote").classList.add("active");
          }

          const originalTransition = activeTabIndicator.style.transition;
          if (skipAnimation) {
            activeTabIndicator.style.transition = "none";
          } else {
            activeTabIndicator.style.transition = "";
          }

          activeTabIndicator.style.left = `${activeButton.offsetLeft}px`;
          activeTabIndicator.style.width = `${activeButton.offsetWidth}px`;

          if (skipAnimation) {
            activeTabIndicator.offsetHeight; // Force reflow
            activeTabIndicator.style.transition = originalTransition;
          }
        }

        tabButtons.forEach((button) => {
          button.addEventListener("click", (e) => {
            setActiveTab(e.currentTarget);
          });
        });

        const initiallyActiveButton = tabNav.querySelector(".tab-button.active");
        if (initiallyActiveButton) {
          requestAnimationFrame(() => { // Use requestAnimationFrame for initial setup
            setActiveTab(initiallyActiveButton, true);
          });
        }

        window.addEventListener("resize", () => {
          requestAnimationFrame(() => { // Use requestAnimationFrame for resize
            const currentActiveButton = tabNav.querySelector(".tab-button.active");
            if (currentActiveButton) {
              setActiveTab(currentActiveButton, true);
            }
          });
        });
      });
    </script>
  </body>
</html>