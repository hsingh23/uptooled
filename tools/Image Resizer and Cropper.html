<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Resizer and Cropper</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="A free online tool to resize, crop, and edit images for any purpose. Perfect for creating favicons, app icons (Chrome extensions, web apps), and social media assets. Features zoom, pan, and custom background colors.">
    <meta name="keywords" content="image resizer, image cropper, icon generator, favicon creator, resize image online, crop image, png resizer, jpeg resizer, chrome extension icons, web app icons">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://tools.privacyfirstapps.org/#tools%2FImage%20Resizer%20and%20Cropper.html">
    <meta property="og:title" content="Free Image Resizer & Cropper - Online Tool">
    <meta property="og:description" content="Easily resize, crop, and edit images for favicons, app icons, and more. Features zoom, pan, and custom background colors.">
    <meta property="og:image" content="https://placehold.co/1200x630/3b82f6/ffffff?text=Image+Resizer\n&cropper">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://tools.privacyfirstapps.org/#tools%2FImage%20Resizer%20and%20Cropper.html">
    <meta property="twitter:title" content="Free Image Resizer & Cropper - Online Tool">
    <meta property="twitter:description" content="Easily resize, crop, and edit images for favicons, app icons, and more. Features zoom, pan, and custom background colors.">
    <meta property="twitter:image" content="https://placehold.co/1200x630/3b82f6/ffffff?text=Image+Resizer\n&cropper">

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        #imageListContainer::-webkit-scrollbar {
            width: 8px;
        }
        #imageListContainer::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        #imageListContainer::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        #imageListContainer::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .thumbnail-selected {
            outline: 3px solid #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        #canvasContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #editorCanvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            border-radius: 0.75rem;
            background-image:
                linear-gradient(45deg, #eee 25%, transparent 25%),
                linear-gradient(-45deg, #eee 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #eee 75%),
                linear-gradient(-45deg, transparent 75%, #eee 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        /* Custom styling for range input */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* gray-300 */
            border-radius: 9999px; /* rounded-full */
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            border: 2px solid white;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* blue-500 */
            border-radius: 9999px; /* rounded-full */
            cursor: pointer;
            border: 2px solid white;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6 space-y-6">
    <header class="mb-6 text-center">
      <h1 class="text-3xl sm:text-4xl font-bold text-blue-600">Image Resizer & Cropper</h1>
      <p class="text-gray-600 mt-1">Upload, zoom, position, set background, and download your images.</p>
    </header>

    <!-- How to Use Guide -->
    <section id="instructionsCard" class="bg-white p-6 rounded-2xl shadow-md border border-blue-100" aria-live="polite">
      <div class="flex flex-col gap-4 sm:flex-row sm:items-start sm:justify-between">
        <div class="space-y-3">
          <div>
            <h2 class="text-xl font-semibold text-gray-700">How to Use This Tool</h2>
            <p class="text-sm text-gray-500 mt-1">Follow these quick steps to get started.</p>
          </div>
          <ol class="list-decimal list-inside space-y-2 text-gray-600">
            <li><strong>Upload:</strong> Choose one or more images from your device.</li>
            <li><strong>Select:</strong> Pick an image from the uploaded list to load it into the editor.</li>
            <li><strong>Set Size:</strong> Use a preset or enter custom dimensions, then click <span class="font-semibold">Set</span>.</li>
            <li><strong>Adjust:</strong> Pinch, scroll, or drag directly on the preview, or refine it with the zoom slider.</li>
            <li><strong>Download:</strong> Save the current size with the single download button below the editor.</li>
          </ol>
        </div>
        <button id="dismissInstructionsButton" type="button" class="self-start px-3 py-2 text-sm font-medium text-blue-600 bg-blue-50 hover:bg-blue-100 rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300">
          Dismiss guide
        </button>
      </div>
    </section>


    <section id="uploadPanel" class="bg-white/90 backdrop-blur-sm border border-gray-200 rounded-2xl shadow-lg p-6">
      <div class="flex flex-col gap-4 md:flex-row md:items-end md:justify-between">
        <div>
          <h2 class="text-2xl font-semibold text-gray-800">Upload &amp; Manage Images</h2>
          <p class="text-sm text-gray-500 mt-1">Drop multiple images at once, then tap a thumbnail to begin editing.</p>
        </div>
        <label class="w-full md:w-auto">
          <span class="sr-only">Choose images to upload</span>
          <input type="file" id="fileInput" multiple accept="image/*" class="block w-full text-sm text-gray-600 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 cursor-pointer">
        </label>
      </div>
      <div class="mt-5">
        <h3 class="text-lg font-semibold text-gray-700 mb-3">Uploaded Images</h3>
        <div id="imageListContainer" class="space-y-3 max-h-[22rem] lg:max-h-[26rem] overflow-y-auto pr-1">
          <p id="noImagesMessage" class="text-gray-500 italic">No images uploaded yet.</p>
        </div>
      </div>
    </section>

    <section id="editorArea" class="w-full bg-white/80 border border-gray-200 rounded-2xl shadow-xl p-6 hidden">
      <div class="flex flex-col gap-8">
        <header class="flex flex-col sm:flex-row sm:items-baseline sm:justify-between gap-2">
          <h2 class="text-2xl font-semibold text-gray-800">Adjust &amp; Export</h2>
          <p class="text-sm text-gray-500">Editing: <span id="currentImageNameDisplay" class="text-blue-600 font-medium"></span></p>
        </header>
        <div class="flex flex-col xl:flex-row gap-8 items-start">
          <div class="flex-1 w-full space-y-6">
            <div class="rounded-2xl border border-gray-200 bg-gradient-to-br from-white to-gray-50 p-4 shadow-inner">
              <div class="flex flex-col sm:flex-row sm:items-end sm:justify-between gap-3 mb-4">
                <div>
                  <h3 class="text-lg font-semibold text-gray-800">Preview &amp; Position</h3>
                  <p class="text-sm text-gray-500">Canvas: <span id="canvasSizeDisplay" class="font-medium">N/A</span></p>
                </div>
                <p class="text-xs text-gray-400">Drag to pan Â· Pinch, scroll, or use the slider to zoom</p>
              </div>
              <div id="canvasContainer" class="relative flex items-center justify-center overflow-hidden rounded-2xl border border-gray-200 bg-white shadow-md h-[360px] sm:h-[480px] lg:h-[640px]">
                <canvas id="editorCanvas" class="cursor-grab active:cursor-grabbing"></canvas>
              </div>
            </div>

            <div class="rounded-2xl border border-gray-200 bg-white/90 p-4 shadow-sm">
              <label for="zoomSlider" class="flex items-center justify-between text-sm font-medium text-gray-700 mb-3">
                <span>Zoom</span>
                <span class="text-gray-500"><span id="zoomValueDisplay">100</span>%</span>
              </label>
              <input type="range" id="zoomSlider" min="10" max="500" value="100" class="w-full">
            </div>
          </div>

          <div class="w-full xl:max-w-sm flex-shrink-0 space-y-5">
            <div class="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
              <h3 class="text-lg font-semibold mb-3 text-gray-800">Target Size</h3>
              <div id="sizeSelectionContainer" class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-1 gap-2 mb-4"></div>
              <div>
                <h4 class="text-sm font-semibold mb-2 text-gray-700">Custom Size (px)</h4>
                <div class="flex flex-wrap items-center gap-2">
                  <input type="number" id="customWidthInput" placeholder="Width" class="w-24 p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                  <span class="font-semibold text-gray-500">Ã</span>
                  <input type="number" id="customHeightInput" placeholder="Height" class="w-24 p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                  <button id="setCustomSizeButton" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-opacity-50">Set</button>
                </div>
              </div>
            </div>

            <div class="rounded-2xl border border-gray-200 bg-white p-4 shadow-sm">
              <h3 class="text-lg font-semibold mb-3 text-gray-800">Background &amp; Canvas</h3>
              <div class="flex flex-wrap items-center gap-3">
                <input type="color" id="bgColorPicker" value="#FFFFFF" class="w-11 h-11 p-1 border border-gray-300 rounded-lg cursor-pointer">
                <input type="text" id="hexColorInput" placeholder="#FFFFFF" class="w-28 p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 text-sm font-mono" maxlength="7">
                <button id="transparentBgButton" class="px-3 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200 text-sm">Transparent BG</button>
              </div>
              <label class="mt-3 flex items-center gap-2 text-sm text-gray-600">
                <input type="checkbox" id="backgroundOnlyMode" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                <span>Background only (no image)</span>
              </label>
            </div>
          </div>
        </div>

        <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
          <h3 class="text-lg font-semibold text-gray-800">Download this size</h3>
          <button id="downloadCurrentImageVersionButton" class="w-full sm:w-auto px-6 py-3 bg-blue-500 text-white rounded-xl hover:bg-blue-600 font-semibold transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center gap-2" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5M16.5 12L12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
            Download <span id="currentVersionSizeDisplay">N/A</span>
          </button>
        </div>
      </div>
    </section>

    <section id="editorPlaceholder" class="w-full bg-white/80 border border-dashed border-gray-300 p-10 rounded-2xl shadow-inner flex flex-col items-center justify-center text-center text-gray-500 min-h-[440px]">
      <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-20 h-20 mb-4 text-gray-400">
        <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 15.75l5.159-5.159a2.25 2.25 0 013.182 0l5.159 5.159m-1.5-1.5l1.409-1.409a2.25 2.25 0 013.182 0l2.909 2.909m-18 3.75h16.5a1.5 1.5 0 001.5-1.5V6a1.5 1.5 0 00-1.5-1.5H3.75A1.5 1.5 0 002.25 6v12a1.5 1.5 0 001.5 1.5zm10.5-11.25h.008v.008h-.008V8.25zm.375 0a.375.375 0 11-.75 0 .375.375 0 01.75 0z" />
      </svg>
      <p class="text-xl font-medium">Select or upload an image to begin.</p>
      <p class="text-sm mt-1">Your preview will fill this workspace once an image is selected.</p>
    </section>
    <footer class="text-center mt-8 text-gray-500 text-sm">
        <p>&copy; 2025 Image Resizer & Cropper. Created with Gemini.</p>
    </footer>

    <!-- Toast Notification Container -->
    <div id="toastContainer" class="fixed bottom-5 right-5 space-y-3 z-50 w-full max-w-xs sm:max-w-sm"></div>
  </div>

<script>
    // DOM Elements
    const instructionsCard = document.getElementById('instructionsCard');
    const dismissInstructionsButton = document.getElementById('dismissInstructionsButton');
    const fileInput = document.getElementById('fileInput');
    const imageListContainer = document.getElementById('imageListContainer');
    const noImagesMessage = document.getElementById('noImagesMessage');
    const editorArea = document.getElementById('editorArea');
    const editorPlaceholder = document.getElementById('editorPlaceholder');
    const currentImageNameDisplay = document.getElementById('currentImageNameDisplay');
    const sizeSelectionContainer = document.getElementById('sizeSelectionContainer');
    const customWidthInput = document.getElementById('customWidthInput');
    const customHeightInput = document.getElementById('customHeightInput');
    const setCustomSizeButton = document.getElementById('setCustomSizeButton');
    const canvasContainer = document.getElementById('canvasContainer');
    const editorCanvas = document.getElementById('editorCanvas');
    const ctx = editorCanvas.getContext('2d');
    const canvasSizeDisplay = document.getElementById('canvasSizeDisplay');
    const downloadCurrentImageVersionButton = document.getElementById('downloadCurrentImageVersionButton');
    const currentVersionSizeDisplay = document.getElementById('currentVersionSizeDisplay');
    const toastContainer = document.getElementById('toastContainer');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValueDisplay = document.getElementById('zoomValueDisplay');
    const bgColorPicker = document.getElementById('bgColorPicker');
    const hexColorInput = document.getElementById('hexColorInput');
    const transparentBgButton = document.getElementById('transparentBgButton');
    const backgroundOnlyMode = document.getElementById('backgroundOnlyMode');

    const MIN_ZOOM = parseInt(zoomSlider.min, 10) / 100;
    const MAX_ZOOM = parseInt(zoomSlider.max, 10) / 100;
    const INSTRUCTIONS_STORAGE_KEY = 'imageResizerInstructionsDismissed';

    // App State
    let imagesData = []; 
    let activeImageId = null;
    let currentTargetSize = null; 
    let originalImageToDraw = null;
    let currentPan = { x: 0, y: 0 };
    let currentZoom = 1.0;
    let currentBackgroundColor = '#FFFFFF';
    let isPanning = false;
    let lastMousePos = { x: 0, y: 0 };
    let isBackgroundOnlyMode = false;
    let previousActiveImageId = null;
    let isPinching = false;
    let initialPinchDistance = 0;
    let initialPinchZoom = 1;
    let lastPinchMidpoint = null;
    let gestureStartZoom = null;

    const PREDEFINED_SIZES = [
        // Original icon sizes
        { name: 'Icon 16x16', width: 16, height: 16 },
        { name: 'Icon 32x32', width: 32, height: 32 },
        { name: 'Icon 48x48', width: 48, height: 48 },
        { name: 'Icon 128x128', width: 128, height: 128 },
        { name: 'Favicon 32x32', width: 32, height: 32 },
        { name: 'Web App Icon 192x192', width: 192, height: 192 },
        { name: 'Web App Icon 512x512', width: 512, height: 512 },
        
        // 16:9 aspect ratio (landscape)
        { name: '16:9 - 1600x900', width: 1600, height: 900 },
        { name: '16:9 - 2400x1350', width: 2400, height: 1350 },
        
        // 9:16 aspect ratio (portrait)
        { name: '9:16 - 900x1600', width: 900, height: 1600 },
        { name: '9:16 - 1350x2400', width: 1350, height: 2400 },
        
        // 4:3 aspect ratio (landscape)
        { name: '4:3 - 1600x1200', width: 1600, height: 1200 },
        { name: '4:3 - 2400x1800', width: 2400, height: 1800 },
        
        // 3:4 aspect ratio (portrait)
        { name: '3:4 - 1200x1600', width: 1200, height: 1600 },
        { name: '3:4 - 1800x2400', width: 1800, height: 2400 },
    ];

    function generateImageId() {
        return `img_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
    }

    function getFileNameWithFallback(file, fallbackPrefix = 'image') {
        if (file && typeof file.name === 'string' && file.name.trim()) {
            return file.name.trim();
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const extension = (file && file.type && file.type.includes('/'))
            ? `.${file.type.split('/')[1] || 'png'}`
            : '.png';

        return `${fallbackPrefix}-${timestamp}${extension}`;
    }

    function processImageFile(file, options = {}) {
        if (!file) return;

        const { nameOverride = null, fallbackPrefix = 'image', successMessage = null } = options;
        const displayName = nameOverride || getFileNameWithFallback(file, fallbackPrefix);
        const imageId = generateImageId();
        const reader = new FileReader();

        reader.onload = (e) => {
            const imgElement = new Image();
            imgElement.onload = () => {
                const newImage = {
                    id: imageId,
                    file,
                    name: displayName,
                    originalSrc: e.target.result,
                    originalWidth: imgElement.naturalWidth,
                    originalHeight: imgElement.naturalHeight,
                    imgElement,
                    processedVersions: {}
                };

                imagesData.push(newImage);
                renderImageListItem(newImage);
                noImagesMessage.classList.add('hidden');

                setActiveImage(imageId);
                updateDownloadButtonsState();

                if (successMessage) {
                    showToast(successMessage, 'success');
                }
            };

            imgElement.onerror = () => showToast(`Error loading image: ${displayName}`, 'error');
            imgElement.src = e.target.result;
        };

        reader.onerror = () => showToast(`Error reading file: ${displayName}`, 'error');
        reader.readAsDataURL(file);
    }

    function setBackgroundOnlyMode(enabled, options = {}) {
        const { deferReset = false, skipRestore = false } = options;

        if (enabled) {
            if (isBackgroundOnlyMode) return;

            if (activeImageId && activeImageId !== 'background-only') {
                previousActiveImageId = activeImageId;
            }

            isBackgroundOnlyMode = true;
            backgroundOnlyMode.checked = true;
            activeImageId = 'background-only';
            originalImageToDraw = null;
            currentImageNameDisplay.textContent = 'Background Only Mode';

            document.querySelectorAll('#imageListContainer > div').forEach(el => {
                el.classList.remove('thumbnail-selected', 'bg-blue-50');
            });

            if (!currentTargetSize && PREDEFINED_SIZES.length > 0) {
                currentTargetSize = { width: PREDEFINED_SIZES[7].width, height: PREDEFINED_SIZES[7].height };
                customWidthInput.value = currentTargetSize.width;
                customHeightInput.value = currentTargetSize.height;
                highlightActiveSizeButton();
            }

            currentZoom = 1.0;
            currentPan.x = 0;
            currentPan.y = 0;

            if (!deferReset) {
                resetZoomAndBgToDefaultsOrStored();
            }

            updateEditorVisibility();
            updateDownloadButtonsState();
            return;
        }

        if (!isBackgroundOnlyMode) return;

        isBackgroundOnlyMode = false;
        backgroundOnlyMode.checked = false;

        if (skipRestore) {
            activeImageId = null;
            originalImageToDraw = null;
            currentImageNameDisplay.textContent = '';
            updateEditorVisibility();
            updateCanvasForNewState();
            updateDownloadButtonsState();
            return;
        }

        if (previousActiveImageId && imagesData.some(img => img.id === previousActiveImageId)) {
            setActiveImage(previousActiveImageId);
        } else if (imagesData.length > 0) {
            setActiveImage(imagesData[0].id);
        } else {
            activeImageId = null;
            originalImageToDraw = null;
            currentImageNameDisplay.textContent = '';
            updateEditorVisibility();
            updateCanvasForNewState();
            updateDownloadButtonsState();
        }
    }

    function ensureBackgroundModeIfNoImage() {
        if (imagesData.length === 0) {
            setBackgroundOnlyMode(true, { deferReset: true });
        }
    }

    function clampZoom(value) {
        return Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, value));
    }

    function updateZoomDisplay(zoomValue) {
        const percent = Math.round(clampZoom(zoomValue) * 100);
        zoomSlider.value = percent;
        zoomValueDisplay.textContent = percent;
    }

    function getTouchDistance(touches) {
        if (!touches || touches.length < 2) return 0;
        const [touch1, touch2] = touches;
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.hypot(dx, dy);
    }

    function getTouchMidpoint(touches) {
        if (!touches || touches.length < 2) return null;
        const [touch1, touch2] = touches;
        return {
            x: (touch1.clientX + touch2.clientX) / 2,
            y: (touch1.clientY + touch2.clientY) / 2,
        };
    }

    function handleWheelZoom(event) {
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;
        if (!event.ctrlKey && !event.metaKey) return;

        event.preventDefault();

        const zoomIntensity = Math.exp(-event.deltaY * 0.0025);
        const nextZoom = clampZoom(currentZoom * zoomIntensity);

        if (Math.abs(nextZoom - currentZoom) < 0.0001) {
            return;
        }

        applyZoom(nextZoom, { origin: { x: event.clientX, y: event.clientY } });
    }

    function handleGestureStart(event) {
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;
        event.preventDefault();
        gestureStartZoom = currentZoom;
    }

    function handleGestureChange(event) {
        if (gestureStartZoom === null) return;
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;

        event.preventDefault();

        const scale = typeof event.scale === 'number' && event.scale > 0 ? event.scale : 1;
        const nextZoom = clampZoom(gestureStartZoom * scale);

        if (Math.abs(nextZoom - currentZoom) < 0.0001) {
            return;
        }

        applyZoom(nextZoom);
    }

    function handleGestureEnd() {
        gestureStartZoom = null;
    }

    function applyZoom(newZoom, options = {}) {
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;

        const { origin = null } = options;
        const clampedZoom = clampZoom(newZoom);

        const rect = editorCanvas.getBoundingClientRect();
        let canvasOriginX = editorCanvas.width / 2;
        let canvasOriginY = editorCanvas.height / 2;

        if (origin && rect.width > 0 && rect.height > 0) {
            const offsetX = origin.x - rect.left;
            const offsetY = origin.y - rect.top;
            const normalizedX = Math.max(0, Math.min(rect.width, offsetX));
            const normalizedY = Math.max(0, Math.min(rect.height, offsetY));
            canvasOriginX = (normalizedX / rect.width) * editorCanvas.width;
            canvasOriginY = (normalizedY / rect.height) * editorCanvas.height;
        }

        const imgPtXAtOrigin = (canvasOriginX - currentPan.x) / currentZoom;
        const imgPtYAtOrigin = (canvasOriginY - currentPan.y) / currentZoom;

        currentZoom = clampedZoom;

        currentPan.x = canvasOriginX - (imgPtXAtOrigin * currentZoom);
        currentPan.y = canvasOriginY - (imgPtYAtOrigin * currentZoom);

        applyPanConstraints();
        updateZoomDisplay(currentZoom);
        redrawCanvasAndStore();
    }

    function handlePasteEvent(event) {
        const clipboardData = event.clipboardData || window.clipboardData;
        if (!clipboardData || !clipboardData.items) return;

        const items = Array.from(clipboardData.items);
        const imageItem = items.find(item => item.type && item.type.startsWith('image/'));

        if (!imageItem) return;

        const file = imageItem.getAsFile();
        if (!file) return;

        event.preventDefault();
        processImageFile(file, {
            fallbackPrefix: 'pasted-image',
            successMessage: 'Pasted image added to the editor.'
        });
    }

    document.addEventListener('DOMContentLoaded', () => {
        let instructionsDismissed = false;
        try {
            instructionsDismissed = localStorage.getItem(INSTRUCTIONS_STORAGE_KEY) === 'true';
        } catch (error) {
            instructionsDismissed = false;
        }

        if (instructionsCard) {
            if (instructionsDismissed) {
                instructionsCard.classList.add('hidden');
                instructionsCard.setAttribute('aria-hidden', 'true');
            } else {
                instructionsCard.classList.remove('hidden');
                instructionsCard.removeAttribute('aria-hidden');
            }
        }

        if (dismissInstructionsButton) {
            dismissInstructionsButton.addEventListener('click', () => {
                if (instructionsCard) {
                    instructionsCard.classList.add('hidden');
                    instructionsCard.setAttribute('aria-hidden', 'true');
                }
                try {
                    localStorage.setItem(INSTRUCTIONS_STORAGE_KEY, 'true');
                } catch (error) {
                    // Ignore storage errors (e.g., private browsing).
                }
            });
        }

        fileInput.addEventListener('change', handleFileSelect);
        setCustomSizeButton.addEventListener('click', handleSetCustomSize);

        editorCanvas.addEventListener('mousedown', startPan);
        editorCanvas.addEventListener('mousemove', panImage);
        editorCanvas.addEventListener('mouseup', endPan);
        editorCanvas.addEventListener('mouseleave', endPan);
        editorCanvas.addEventListener('touchstart', startPan, { passive: false });
        editorCanvas.addEventListener('touchmove', panImage, { passive: false });
        editorCanvas.addEventListener('touchend', endPan);
        editorCanvas.addEventListener('touchcancel', endPan);

        if (canvasContainer) {
            canvasContainer.addEventListener('wheel', handleWheelZoom, { passive: false });
            canvasContainer.addEventListener('gesturestart', handleGestureStart);
            canvasContainer.addEventListener('gesturechange', handleGestureChange);
            canvasContainer.addEventListener('gestureend', handleGestureEnd);
        }

        zoomSlider.addEventListener('input', handleZoomChange);
        bgColorPicker.addEventListener('input', handleBgColorChange);
        hexColorInput.addEventListener('input', handleHexColorChange);
        hexColorInput.addEventListener('blur', validateHexColor);
        transparentBgButton.addEventListener('click', setTransparentBackground);
        backgroundOnlyMode.addEventListener('change', handleBackgroundOnlyModeChange);

        downloadCurrentImageVersionButton.addEventListener('click', downloadCurrentVersion);

        populatePredefinedSizes();
        updateEditorVisibility();
        updateDownloadButtonsState();
        document.addEventListener('paste', handlePasteEvent);
    });

    function populatePredefinedSizes() {
        PREDEFINED_SIZES.forEach(size => {
            const button = document.createElement('button');
            button.textContent = `${size.name} (${size.width}x${size.height})`;
            button.classList.add('w-full', 'text-sm', 'text-left', 'px-3', 'py-2', 'bg-gray-200', 'text-gray-700', 'rounded-md', 'hover:bg-gray-300', 'transition-colors', 'focus:outline-none', 'focus:ring-2', 'focus:ring-blue-500');
            button.onclick = () => {
                currentTargetSize = { width: size.width, height: size.height };
                customWidthInput.value = size.width;
                customHeightInput.value = size.height;
                ensureBackgroundModeIfNoImage();
                resetZoomAndBgToDefaultsOrStored();
                highlightActiveSizeButton();
            };
            sizeSelectionContainer.appendChild(button);
        });
    }
    
    function highlightActiveSizeButton() {
        Array.from(sizeSelectionContainer.children).forEach(button => {
            button.classList.remove('bg-blue-500', 'text-white', 'ring-2', 'ring-blue-300');
            button.classList.add('bg-gray-200', 'text-gray-700');
            if (currentTargetSize) {
                 const sizeFromButtonText = button.textContent.match(/(\d+)x(\d+)/);
                 if (sizeFromButtonText && parseInt(sizeFromButtonText[1]) === currentTargetSize.width && parseInt(sizeFromButtonText[2]) === currentTargetSize.height) {
                    const matchingPredefined = PREDEFINED_SIZES.find(s => s.width === currentTargetSize.width && s.height === currentTargetSize.height && button.textContent.startsWith(s.name));
                    if (matchingPredefined) {
                         button.classList.add('bg-blue-500', 'text-white', 'ring-2', 'ring-blue-300');
                         button.classList.remove('bg-gray-200', 'text-gray-700');
                    }
                 }
            }
        });
    }

    function handleFileSelect(event) {
        const files = event.target.files;
        if (!files.length) return;
        Array.from(files).forEach(file => {
            const displayName = getFileNameWithFallback(file, 'image');
            processImageFile(file, {
                nameOverride: displayName,
                successMessage: `${displayName} added to the editor.`
            });
        });
        fileInput.value = '';
    }

    function renderImageListItem(imgData) {
        const item = document.createElement('div');
        item.classList.add('p-3', 'border', 'border-gray-200', 'rounded-lg', 'flex', 'items-center', 'gap-3', 'cursor-pointer', 'hover:bg-gray-50', 'transition-colors');
        item.dataset.imageId = imgData.id;
        item.title = imgData.name;

        const thumb = document.createElement('img');
        thumb.src = imgData.originalSrc;
        thumb.alt = imgData.name;
        thumb.classList.add('w-12', 'h-12', 'object-cover', 'rounded-md', 'border', 'border-gray-300', 'flex-shrink-0');

        const nameEl = document.createElement('span');
        nameEl.textContent = imgData.name;
        nameEl.classList.add('text-sm', 'font-medium', 'text-gray-700', 'flex-grow', 'truncate');
        
        const checkmarkContainer = document.createElement('div');
        checkmarkContainer.classList.add('w-5', 'h-5', 'text-green-500', 'opacity-0', 'transition-opacity', 'duration-300', 'flex-shrink-0');
        checkmarkContainer.id = `checkmark-${imgData.id}`;
        checkmarkContainer.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-full h-full"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75L11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>`;
        
        item.appendChild(thumb);
        item.appendChild(nameEl);
        item.appendChild(checkmarkContainer);

        item.onclick = () => setActiveImage(imgData.id);
        imageListContainer.appendChild(item);
    }
    
    function updateImageListItemProcessedState(imageId) {
        const imgData = imagesData.find(img => img.id === imageId);
        const checkmark = document.getElementById(`checkmark-${imageId}`);
        if (imgData && checkmark) {
            const hasProcessedVersions = Object.keys(imgData.processedVersions).length > 0;
            checkmark.style.opacity = hasProcessedVersions ? '1' : '0';
        }
    }

    function setActiveImage(imageId) {
        if (isBackgroundOnlyMode) {
            setBackgroundOnlyMode(false, { skipRestore: true });
        }

        if (activeImageId === imageId && originalImageToDraw) return;

        activeImageId = imageId;
        const imgData = imagesData.find(img => img.id === activeImageId);

        if (!imgData) {
            activeImageId = null;
            originalImageToDraw = null;
            currentImageNameDisplay.textContent = '';
            updateEditorVisibility();
            return;
        }

        previousActiveImageId = activeImageId;

        currentImageNameDisplay.textContent = imgData.name;
        originalImageToDraw = imgData.imgElement;

        document.querySelectorAll('#imageListContainer > div').forEach(el => {
            el.classList.remove('thumbnail-selected', 'bg-blue-50');
            if (el.dataset.imageId === imageId) {
                el.classList.add('thumbnail-selected', 'bg-blue-50');
            }
        });
        
        updateEditorVisibility();
        if (currentTargetSize) {
            resetZoomAndBgToDefaultsOrStored();
        } else {
            if (PREDEFINED_SIZES.length > 0) {
                 currentTargetSize = { width: PREDEFINED_SIZES[3].width, height: PREDEFINED_SIZES[3].height }; // Default to 128x128
                 customWidthInput.value = currentTargetSize.width;
                 customHeightInput.value = currentTargetSize.height;
                 resetZoomAndBgToDefaultsOrStored();
                 highlightActiveSizeButton();
            }
        }
        updateDownloadButtonsState();
    }

    function handleSetCustomSize() {
        const width = parseInt(customWidthInput.value);
        const height = parseInt(customHeightInput.value);

        if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
            showToast('Please enter valid positive numbers for width and height.', 'error');
            return;
        }
        currentTargetSize = { width, height };
        ensureBackgroundModeIfNoImage();
        resetZoomAndBgToDefaultsOrStored();
        highlightActiveSizeButton();
    }

    function resetZoomAndBgToDefaultsOrStored() {
        if (!activeImageId || !currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) {
            updateCanvasForNewState();
            return;
        }

        if (isBackgroundOnlyMode) {
            // Background-only mode
            const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;
            const storedVersion = window.backgroundOnlyVersions ? window.backgroundOnlyVersions[sizeKey] : null;
            
            if (storedVersion) {
                currentBackgroundColor = storedVersion.backgroundColor;
            }
            // If no stored version, keep the current background color (don't reset to white)
            
            // Reset zoom and pan for background mode
            currentZoom = 1.0;
            currentPan.x = 0;
            currentPan.y = 0;
        } else {
            // Regular image mode
            const imgData = imagesData.find(img => img.id === activeImageId);
            const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;
            const storedVersion = imgData.processedVersions[sizeKey];

            if (storedVersion) {
                currentZoom = storedVersion.zoom;
                currentBackgroundColor = storedVersion.backgroundColor;
                currentPan.x = storedVersion.panX;
                currentPan.y = storedVersion.panY;
            } else {
                const zoomX = currentTargetSize.width / originalImageToDraw.naturalWidth;
                const zoomY = currentTargetSize.height / originalImageToDraw.naturalHeight;
                currentZoom = Math.max(zoomX, zoomY);
                
                const drawWidth = originalImageToDraw.naturalWidth * currentZoom;
                const drawHeight = originalImageToDraw.naturalHeight * currentZoom;
                currentPan.x = (currentTargetSize.width - drawWidth) / 2;
                currentPan.y = (currentTargetSize.height - drawHeight) / 2;
                
                currentBackgroundColor = '#FFFFFF';
            }
        }
        
        currentZoom = clampZoom(currentZoom);
        updateZoomDisplay(currentZoom);
        bgColorPicker.value = currentBackgroundColor === 'transparent' ? '#FFFFFF' : currentBackgroundColor;
        hexColorInput.value = currentBackgroundColor === 'transparent' ? '#FFFFFF' : currentBackgroundColor.toUpperCase();

        updateCanvasForNewState();
    }


    function updateCanvasForNewState() {
        if (!activeImageId || !currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) {
            ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
            editorCanvas.style.width = '0px';
            editorCanvas.style.height = '0px';
            canvasSizeDisplay.textContent = 'N/A';
            currentVersionSizeDisplay.textContent = 'N/A';
            updateDownloadButtonsState();
            return;
        }
        
        editorCanvas.width = currentTargetSize.width;
        editorCanvas.height = currentTargetSize.height;

        const canvasAspectRatio = editorCanvas.width / editorCanvas.height;
        const containerWidth = canvasContainer.clientWidth || editorCanvas.width;
        const containerHeight = canvasContainer.clientHeight || Math.min(640, window.innerHeight * 0.75);

        let displayW = containerWidth;
        let displayH = displayW / canvasAspectRatio;

        const maxDisplayHeight = Math.min(containerHeight, window.innerHeight * 0.85);

        if (displayH > maxDisplayHeight) {
            displayH = maxDisplayHeight;
            displayW = displayH * canvasAspectRatio;
        }

        if (displayW > containerWidth) {
            displayW = containerWidth;
            displayH = displayW / canvasAspectRatio;
        }

        editorCanvas.style.width = `${displayW}px`;
        editorCanvas.style.height = `${displayH}px`;

        canvasSizeDisplay.textContent = `${currentTargetSize.width}x${currentTargetSize.height}px`;
        currentVersionSizeDisplay.textContent = `${currentTargetSize.width}x${currentTargetSize.height}`;
        
        applyPanConstraints(); 
        redrawCanvasAndStore();
        updateDownloadButtonsState();
    }
    
    function handleZoomChange(event) {
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;

        const newZoomSliderValue = parseInt(event.target.value, 10);
        const newZoom = newZoomSliderValue / 100;
        applyZoom(newZoom);
    }

    function handleBgColorChange(event) {
        currentBackgroundColor = event.target.value;
        hexColorInput.value = currentBackgroundColor.toUpperCase();
        redrawCanvasAndStore();
    }

    function handleHexColorChange(event) {
        const hexValue = event.target.value;
        if (isValidHexColor(hexValue)) {
            currentBackgroundColor = hexValue;
            bgColorPicker.value = hexValue;
            redrawCanvasAndStore();
        }
    }

    function validateHexColor(event) {
        const hexValue = event.target.value;
        if (hexValue && !isValidHexColor(hexValue)) {
            showToast('Invalid hex color format. Use #RRGGBB format.', 'error');
            hexColorInput.value = currentBackgroundColor === 'transparent' ? '#FFFFFF' : currentBackgroundColor;
        } else if (!hexValue) {
            hexColorInput.value = currentBackgroundColor === 'transparent' ? '#FFFFFF' : currentBackgroundColor;
        }
    }

    function isValidHexColor(hex) {
        return /^#[0-9A-Fa-f]{6}$/.test(hex);
    }

    function setTransparentBackground() {
        currentBackgroundColor = 'transparent';
        bgColorPicker.value = '#FFFFFF';
        hexColorInput.value = '#FFFFFF';
        showToast('Background set to transparent.', 'info');
        redrawCanvasAndStore();
    }

    function handleBackgroundOnlyModeChange(event) {
        setBackgroundOnlyMode(event.target.checked);
    }
    
    function applyPanConstraints() {
        if ((!originalImageToDraw && !isBackgroundOnlyMode) || !currentTargetSize) return;

        // In background-only mode, there's no image to constrain
        if (isBackgroundOnlyMode) return;

        const drawWidth = originalImageToDraw.naturalWidth * currentZoom;
        const drawHeight = originalImageToDraw.naturalHeight * currentZoom;

        // For small images (smaller than canvas), allow positioning anywhere within canvas bounds
        // For large images (larger than canvas), constrain to show at least some part of the image
        let minPanX, maxPanX, minPanY, maxPanY;
        
        if (drawWidth <= editorCanvas.width) {
            // Small image horizontally - allow positioning anywhere from left edge to right edge
            minPanX = 0 - drawWidth;
            maxPanX = editorCanvas.width;
        } else {
            // Large image horizontally - constrain to show some part of the image
            minPanX = editorCanvas.width - drawWidth;
            maxPanX = 0;
        }
        
        if (drawHeight <= editorCanvas.height) {
            // Small image vertically - allow positioning anywhere from top edge to bottom edge
            minPanY = 0 - drawHeight;
            maxPanY = editorCanvas.height;
        } else {
            // Large image vertically - constrain to show some part of the image
            minPanY = editorCanvas.height - drawHeight;
            maxPanY = 0;
        }
        
        currentPan.x = Math.max(minPanX, Math.min(maxPanX, currentPan.x));
        currentPan.y = Math.max(minPanY, Math.min(maxPanY, currentPan.y));
    }


    function redrawCanvasAndStore() {
        if (!currentTargetSize) return;

        ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
        
        if (currentBackgroundColor && currentBackgroundColor !== 'transparent') {
            ctx.fillStyle = currentBackgroundColor;
            ctx.fillRect(0, 0, editorCanvas.width, editorCanvas.height);
        }

        // Only draw image if we have one and not in background-only mode
        if (originalImageToDraw && !isBackgroundOnlyMode) {
            const drawWidth = originalImageToDraw.naturalWidth * currentZoom;
            const drawHeight = originalImageToDraw.naturalHeight * currentZoom;
            ctx.drawImage(originalImageToDraw, currentPan.x, currentPan.y, drawWidth, drawHeight);
        }

        const dataURL = editorCanvas.toDataURL('image/png'); 
        
        if (isBackgroundOnlyMode) {
            // Store background-only version in a special location
            if (!window.backgroundOnlyVersions) {
                window.backgroundOnlyVersions = {};
            }
            const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;
            window.backgroundOnlyVersions[sizeKey] = {
                dataURL,
                backgroundColor: currentBackgroundColor,
                targetWidth: currentTargetSize.width,
                targetHeight: currentTargetSize.height
            };
        } else {
            const imgData = imagesData.find(img => img.id === activeImageId);
            if (imgData) {
                const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;
                imgData.processedVersions[sizeKey] = {
                    dataURL,
                    panX: currentPan.x,
                    panY: currentPan.y,
                    zoom: currentZoom,
                    backgroundColor: currentBackgroundColor,
                    targetWidth: currentTargetSize.width,
                    targetHeight: currentTargetSize.height
                };
                updateImageListItemProcessedState(activeImageId);
            }
        }
        updateDownloadButtonsState();
    }
    
    function getEventCoordinates(event) {
        if (event.touches && event.touches.length > 0) {
            return { x: event.touches[0].clientX, y: event.touches[0].clientY };
        }
        return { x: event.clientX, y: event.clientY };
    }

    function startPan(event) {
        if (!currentTargetSize || (!originalImageToDraw && !isBackgroundOnlyMode)) return;

        if (event.touches) {
            if (event.touches.length === 2) {
                event.preventDefault();
                isPinching = true;
                isPanning = false;
                initialPinchDistance = getTouchDistance(event.touches);
                initialPinchZoom = currentZoom;
                lastPinchMidpoint = getTouchMidpoint(event.touches);
                editorCanvas.classList.remove('cursor-grab');
                editorCanvas.classList.add('cursor-grabbing');
                return;
            }

            if (event.touches.length > 2) {
                return;
            }
        }

        event.preventDefault();
        isPinching = false;
        isPanning = true;
        lastPinchMidpoint = null;
        editorCanvas.classList.remove('cursor-grab');
        editorCanvas.classList.add('cursor-grabbing');
        const coords = getEventCoordinates(event);
        lastMousePos = { x: coords.x, y: coords.y };
    }

    function panImage(event) {
        if (isPinching && event.touches && event.touches.length >= 2) {
            event.preventDefault();
            const newDistance = getTouchDistance(event.touches);
            if (initialPinchDistance > 0) {
                const zoomFactor = newDistance / initialPinchDistance;
                const midpoint = getTouchMidpoint(event.touches) || lastPinchMidpoint;
                lastPinchMidpoint = midpoint;
                applyZoom(initialPinchZoom * zoomFactor, { origin: midpoint });
            }
            return;
        }

        if (!isPanning) return;
        event.preventDefault();

        const coords = getEventCoordinates(event);
        const currentMousePos = { x: coords.x, y: coords.y };

        const scaleX = editorCanvas.width / editorCanvas.offsetWidth;
        const scaleY = editorCanvas.height / editorCanvas.offsetHeight;

        const dx = (currentMousePos.x - lastMousePos.x) * (editorCanvas.offsetWidth > 0 ? scaleX : 1);
        const dy = (currentMousePos.y - lastMousePos.y) * (editorCanvas.offsetHeight > 0 ? scaleY : 1);

        currentPan.x += dx;
        currentPan.y += dy;

        applyPanConstraints();
        lastMousePos = currentMousePos;
        redrawCanvasAndStore();
    }

    function endPan(event) {
        const remainingTouches = event && event.touches ? event.touches.length : 0;

        if (isPinching) {
            if (remainingTouches >= 2) {
                return;
            }
            isPinching = false;
            initialPinchDistance = 0;
            lastPinchMidpoint = null;
        }

        if (!isPanning) {
            editorCanvas.classList.remove('cursor-grabbing');
            editorCanvas.classList.add('cursor-grab');
            return;
        }

        isPanning = false;
        editorCanvas.classList.remove('cursor-grabbing');
        editorCanvas.classList.add('cursor-grab');
        if (activeImageId && currentTargetSize) {
             redrawCanvasAndStore();
        }
    }
    
    function updateEditorVisibility() {
        if (activeImageId) {
            editorArea.classList.remove('hidden');
            editorPlaceholder.classList.add('hidden');
        } else {
            editorArea.classList.add('hidden');
            editorPlaceholder.classList.remove('hidden');
        }
    }

    function updateDownloadButtonsState() {
        let currentVersionExists = false;

        if (currentTargetSize) {
            const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;

            if (isBackgroundOnlyMode) {
                if (window.backgroundOnlyVersions && window.backgroundOnlyVersions[sizeKey]) {
                    currentVersionExists = true;
                }
            } else {
                const imgData = imagesData.find(img => img.id === activeImageId);
                if (imgData && imgData.processedVersions[sizeKey] && imgData.processedVersions[sizeKey].dataURL) {
                    currentVersionExists = true;
                }
            }
        }

        downloadCurrentImageVersionButton.disabled = !currentVersionExists;
    }

    function downloadCurrentVersion() {
        if (!activeImageId || !currentTargetSize) return;
        
        const sizeKey = `${currentTargetSize.width}x${currentTargetSize.height}`;
        
        if (isBackgroundOnlyMode) {
            const version = window.backgroundOnlyVersions?.[sizeKey];
            if (version?.dataURL) {
                triggerDownload(version.dataURL, `background_${version.targetWidth}x${version.targetHeight}.png`);
                showToast(`Downloading ${version.targetWidth}x${version.targetHeight} background.`, 'success');
            } else {
                showToast('No processed version available for this size.', 'error');
            }
        } else {
            const imgData = imagesData.find(img => img.id === activeImageId);
            const version = imgData?.processedVersions[sizeKey];

            if (version?.dataURL) {
                triggerDownload(version.dataURL, `${getSafeFilenameBase(imgData.name)}_${version.targetWidth}x${version.targetHeight}.png`);
                showToast(`Downloading ${version.targetWidth}x${version.targetHeight} version.`, 'success');
            } else {
                showToast('No processed version available for this size.', 'error');
            }
        }
    }

    function getSafeFilenameBase(originalName) {
        const nameWithoutExt = originalName.includes('.') ? originalName.substring(0, originalName.lastIndexOf('.')) : originalName;
        return nameWithoutExt.replace(/[^a-zA-Z0-9_-]/g, '_') || 'image';
    }

    function triggerDownload(dataURL, filename) {
        const link = document.createElement('a');
        link.href = dataURL;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }

    function showToast(message, type = 'info') {
        const toastId = `toast-${Date.now()}`;
        let bgColorClass = 'bg-blue-500'; 
        if (type === 'success') bgColorClass = 'bg-green-500';
        if (type === 'error') bgColorClass = 'bg-red-500';

        const toastElement = document.createElement('div');
        toastElement.id = toastId;
        toastElement.className = `p-4 rounded-lg shadow-lg text-white text-sm ${bgColorClass} transition-all duration-300 opacity-0 translate-y-2`;
        toastElement.textContent = message;
        
        toastContainer.prepend(toastElement);

        requestAnimationFrame(() => {
            toastElement.classList.remove('opacity-0', 'translate-y-2');
            toastElement.classList.add('opacity-100', 'translate-y-0');
        });

        setTimeout(() => {
            toastElement.classList.remove('opacity-100', 'translate-y-0');
            toastElement.classList.add('opacity-0', 'translate-y-2');
            setTimeout(() => toastElement.remove(), 300); 
        }, type === 'info' ? 2000 : 3000);
    }

</script>
</body>
</html>
