<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Image Resizer and Cropper</title>

<!-- SEO Meta Tags -->
<meta name="description" content="A free online tool to resize, crop, and edit images for any purpose. Perfect for creating favicons, app icons (Chrome extensions, web apps), and social media assets. Features zoom, pan, and custom background colors.">
<meta name="keywords" content="image resizer, image cropper, icon generator, favicon creator, resize image online, crop image, png resizer, jpeg resizer, chrome extension icons, web app icons">

<!-- Open Graph / Facebook -->
<meta property="og:type" content="website">
<meta property="og:url" content="https://tools.privacyfirstapps.org/#tools%2FImage%20Resizer%20and%20Cropper.html">
<meta property="og:title" content="Free Image Resizer & Cropper - Online Tool">
<meta property="og:description" content="Easily resize, crop, and edit images for favicons, app icons, and more. Features zoom, pan, and custom background colors.">
<meta property="og:image" content="https://placehold.co/1200x630/3b82f6/ffffff?text=Image+Resizer\n&cropper">

<!-- Twitter -->
<meta property="twitter:card" content="summary_large_image">
<meta property="twitter:url" content="https://tools.privacyfirstapps.org/#tools%2FImage%20Resizer%20and%20Cropper.html">
<meta property="twitter:title" content="Free Image Resizer & Cropper - Online Tool">
<meta property="twitter:description" content="Easily resize, crop, and edit images for favicons, app icons, and more. Features zoom, pan, and custom background colors.">
<meta property="twitter:image" content="https://placehold.co/1200x630/3b82f6/ffffff?text=Image+Resizer\n&cropper">


    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=Space+Mono:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
          theme: {
              extend: {
                  colors: {
                      'brutal-bg': '#f3f4f6',
                      'brutal-accent': '#a3e635', /* Lime Green */
                      'brutal-accent-hover': '#84cc16',
                      'brutal-dark': '#111827',
                  },
                  boxShadow: {
                      'brutal': '5px 5px 0px 0px rgba(0,0,0,1)',
                      'brutal-sm': '3px 3px 0px 0px rgba(0,0,0,1)',
                      'brutal-hover': '2px 2px 0px 0px rgba(0,0,0,1)',
                      'brutal-active': '0px 0px 0px 0px rgba(0,0,0,1)',
                  },
                  fontFamily: {
                      'display': ['"Archivo Black"', 'sans-serif'],
                      'mono': ['"Space Mono"', 'monospace'],
                  }
              }
          }
      }
    </script>

    <style>
      body {
        background-color: #e5e7eb;
        background-image: radial-gradient(#cbd5e1 2px, transparent 2px);
        background-size: 24px 24px;
      }

      /* Scrollbar Styling */
      ::-webkit-scrollbar {
        width: 12px;
        height: 12px;
      }
      ::-webkit-scrollbar-track {
        background: #fff;
        border-left: 2px solid #000;
      }
      ::-webkit-scrollbar-thumb {
        background: #000;
        border: 2px solid #fff;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #a3e635;
      }

      /* Range Slider Styling */
      input[type="range"] {
        -webkit-appearance: none;
        width: 100%;
        background: transparent;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 24px;
        width: 24px;
        background: #a3e635;
        border: 2px solid black;
        cursor: pointer;
        margin-top: -10px;
        box-shadow: 2px 2px 0px black;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: #000;
        border-radius: 0;
      }

      /* Checkbox */
      .brutal-checkbox {
        appearance: none;
        width: 20px;
        height: 20px;
        border: 2px solid black;
        background: white;
        cursor: pointer;
        position: relative;
      }
      .brutal-checkbox:checked {
        background: #000;
      }
      .brutal-checkbox:checked::after {
        content: "âœ“";
        color: #a3e635;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        font-weight: bold;
      }

      /* The Editing Canvas Pattern (The "Checkerboard") */
      #editorCanvas {
        background-image: linear-gradient(45deg, #d1d5db 25%, transparent 25%),
          linear-gradient(-45deg, #d1d5db 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #d1d5db 75%),
          linear-gradient(-45deg, transparent 75%, #d1d5db 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        background-color: #fff;
        /* Crucial: Hard border on the canvas itself so users see the dimensions */
        box-shadow: 0 0 0 4px #000000;
      }

      /* The Stage behind the canvas */
      #canvasContainer {
        background-color: #262626; /* Dark background to contrast white borders */
        background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
          linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
        background-size: 40px 40px;
      }

      .thumbnail-selected {
        border-color: #000 !important;
        background-color: #a3e635 !important;
        box-shadow: 3px 3px 0px 0px rgba(0, 0, 0, 1);
        transform: translate(-2px, -2px);
      }
    </style>
  </head>
  <body class="font-mono text-black min-h-screen p-4 md:p-8">
    <div class="max-w-[1800px] mx-auto space-y-8">
      <!-- Header -->
      <header
        class="flex flex-col md:flex-row md:items-end justify-between gap-4 border-b-4 border-black pb-6 bg-white p-6 shadow-brutal"
      >
        <div>
          <h1 class="font-display text-4xl md:text-6xl uppercase tracking-tighter leading-none">
            Raw<span class="text-brutal-accent bg-black px-2">Crop</span>
          </h1>
          <p class="font-bold text-lg mt-2">The Brutalist Image Resizer.</p>
        </div>
        <div class="text-xs font-bold max-w-sm">
          <p>1. UPLOAD > 2. SIZE > 3. POSITION > 4. EXPORT</p>
          <p class="mt-1 opacity-60">High contrast for pixel-perfect transparency control.</p>
        </div>
      </header>

      <!-- Instructions Banner -->
      <div
        id="instructionsCard"
        class="bg-brutal-accent border-4 border-black p-4 shadow-brutal flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4 transition-all"
      >
        <div class="font-bold text-sm">
          <span class="bg-black text-white px-2 py-1 mr-2">TIP</span>
          Scroll to zoom. Drag to pan. The checkerboard is transparent. The dark area is outside
          your image.
        </div>
        <button
          id="dismissInstructionsButton"
          class="border-2 border-black bg-white px-3 py-1 text-xs font-bold hover:bg-black hover:text-white transition-colors shadow-brutal-sm hover:shadow-brutal-hover active:translate-y-1 active:shadow-brutal-active"
        >
          GOT IT [X]
        </button>
      </div>

      <!-- Main Grid -->
      <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
        <!-- LEFT COLUMN: Controls & Uploads -->
        <div class="lg:col-span-4 xl:col-span-3 space-y-8 flex flex-col h-full">
          <!-- Upload Section -->
          <section class="bg-white border-4 border-black p-5 shadow-brutal">
            <h2 class="font-display text-2xl mb-4 uppercase border-b-4 border-black inline-block">
              1. Inputs
            </h2>

            <label class="block w-full cursor-pointer group">
              <div
                class="border-2 border-dashed border-black bg-gray-50 p-6 text-center group-hover:bg-brutal-accent/20 transition-colors"
              >
                <span class="font-bold block text-lg">CLICK TO UPLOAD</span>
                <span class="text-xs block mt-1">or drag & drop images</span>
              </div>
              <input type="file" id="fileInput" multiple accept="image/*" class="hidden" />
            </label>

            <div
              id="imageListContainer"
              class="mt-4 space-y-2 max-h-[250px] overflow-y-auto pr-2 border-t-2 border-black pt-2"
            >
              <p id="noImagesMessage" class="text-sm text-gray-400 font-bold py-2">[EMPTY_QUEUE]</p>
              <!-- Image items injected here -->
            </div>
          </section>

          <!-- Sizing Controls (Visible only when active) -->
          <section
            id="sizingControls"
            class="bg-white border-4 border-black p-5 shadow-brutal hidden flex-grow"
          >
            <h2 class="font-display text-2xl mb-4 uppercase border-b-4 border-black inline-block">
              2. Dimensions
            </h2>

            <div class="space-y-4">
              <div>
                <label class="block font-bold text-xs mb-1 uppercase">Preset Sizes</label>
                <div class="relative">
                  <select
                    id="targetSizeSelect"
                    class="w-full appearance-none border-2 border-black bg-white p-3 font-bold text-sm focus:outline-none focus:bg-gray-50 rounded-none cursor-pointer"
                  >
                    <option value="">CHOOSE SIZE...</option>
                  </select>
                  <div
                    class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-3 text-black"
                  >
                    <svg
                      class="fill-current h-4 w-4"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 20 20"
                    >
                      <path
                        d="M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z"
                      />
                    </svg>
                  </div>
                </div>
              </div>

              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="block font-bold text-xs mb-1">W (PX)</label>
                  <input
                    type="number"
                    id="customWidthInput"
                    class="w-full border-2 border-black p-2 font-bold focus:outline-none focus:ring-2 focus:ring-brutal-accent placeholder-gray-400"
                    placeholder="0"
                  />
                </div>
                <div>
                  <label class="block font-bold text-xs mb-1">H (PX)</label>
                  <input
                    type="number"
                    id="customHeightInput"
                    class="w-full border-2 border-black p-2 font-bold focus:outline-none focus:ring-2 focus:ring-brutal-accent placeholder-gray-400"
                    placeholder="0"
                  />
                </div>
              </div>
              <button
                id="setCustomSizeButton"
                class="w-full bg-black text-white py-2 font-bold hover:bg-brutal-accent hover:text-black border-2 border-black transition-colors"
              >
                APPLY CUSTOM SIZE
              </button>
            </div>

            <div class="mt-8 pt-4 border-t-4 border-black">
              <h2 class="font-display text-2xl mb-4 uppercase border-b-4 border-black inline-block">
                3. Settings
              </h2>

              <div class="space-y-3">
                <!-- Zoom Control -->
                <div>
                  <label class="flex justify-between font-bold text-xs mb-1">
                    <span>ZOOM</span>
                    <span id="zoomValueDisplay">100%</span>
                  </label>
                  <input type="range" id="zoomSlider" min="10" max="500" value="100" />
                </div>

                <!-- Background Control -->
                <div class="flex items-center gap-2 mt-4">
                  <input
                    type="color"
                    id="bgColorPicker"
                    value="#FFFFFF"
                    class="h-10 w-10 border-2 border-black p-0 cursor-pointer"
                  />
                  <input
                    type="text"
                    id="hexColorInput"
                    placeholder="#FFFFFF"
                    class="flex-1 border-2 border-black p-2 font-bold uppercase text-sm"
                    maxlength="7"
                  />
                </div>

                <button
                  id="transparentBgButton"
                  class="w-full mt-2 border-2 border-dashed border-gray-400 text-gray-500 py-1 text-xs font-bold hover:border-black hover:text-black hover:bg-gray-100"
                >
                  SET TRANSPARENT
                </button>

                <label
                  class="flex items-center gap-3 mt-4 pt-4 border-t-2 border-gray-200 cursor-pointer"
                >
                  <input type="checkbox" id="backgroundOnlyMode" class="brutal-checkbox" />
                  <span class="font-bold text-sm">Background Only (No Image)</span>
                </label>
              </div>
            </div>
          </section>
        </div>

        <!-- RIGHT COLUMN: Editor Canvas & Download -->
        <div class="lg:col-span-8 xl:col-span-9 flex flex-col gap-6">
          <!-- Editor Wrapper -->
          <section
            class="flex-grow flex flex-col bg-white border-4 border-black shadow-brutal h-[600px] lg:h-[750px] relative"
          >
            <header
              class="flex justify-between items-center p-3 border-b-4 border-black bg-white z-10"
            >
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-red-500 border border-black"></div>
                <div class="w-3 h-3 rounded-full bg-yellow-400 border border-black"></div>
                <div class="w-3 h-3 rounded-full bg-green-500 border border-black"></div>
                <span class="ml-2 font-bold text-sm uppercase tracking-widest">Workspace</span>
              </div>
              <div class="font-mono text-xs font-bold bg-black text-white px-2 py-1">
                CANVAS: <span id="canvasSizeDisplay">N/A</span>
              </div>
            </header>

            <!-- The Canvas Container -->
            <div
              id="canvasContainer"
              class="flex-grow relative flex items-center justify-center overflow-hidden w-full h-full cursor-crosshair"
            >
              <!-- Placeholder State -->
              <div
                id="editorPlaceholder"
                class="text-center p-8 bg-white border-4 border-black shadow-brutal rotate-[-2deg]"
              >
                <h3 class="font-display text-3xl mb-2">NO SIGNAL</h3>
                <p class="font-mono text-sm">
                  Select an image from the left<br />to begin transmission.
                </p>
              </div>

              <!-- The Actual Canvas -->
              <canvas id="editorCanvas" class="hidden cursor-grab active:cursor-grabbing"></canvas>
            </div>
          </section>

          <!-- Download Section -->
          <section class="grid grid-cols-1 md:grid-cols-2 gap-6">
            <div class="bg-black text-white p-6 shadow-brutal border-4 border-black md:col-start-2">
              <div class="flex flex-col gap-4">
                <div class="flex justify-between items-baseline">
                  <h2 class="font-display text-2xl uppercase text-brutal-accent">4. Export</h2>
                  <span
                    id="currentVersionSizeDisplay"
                    class="font-mono text-sm border border-white px-2"
                    >N/A</span
                  >
                </div>
                <button
                  id="downloadCurrentImageVersionButton"
                  disabled
                  class="w-full bg-brutal-accent text-black border-2 border-transparent py-4 text-xl font-display uppercase tracking-widest hover:bg-white hover:border-brutal-accent transition-all disabled:opacity-50 disabled:cursor-not-allowed shadow-[4px_4px_0px_white] active:shadow-none active:translate-x-1 active:translate-y-1"
                >
                  Download Image
                </button>
              </div>
            </div>
          </section>
        </div>
      </div>

      <footer class="text-center py-8 text-xs font-bold opacity-50 uppercase">
        <p>&copy; 2025 Image Resizer & Cropper. Brutalist Edition.</p>
      </footer>

      <!-- Toast Notification Container -->
      <div
        id="toastContainer"
        class="fixed bottom-8 left-8 space-y-3 z-50 w-full max-w-xs pointer-events-none"
      ></div>
    </div>

    <script>
      // --- Logic Implementation ---

      // DOM Elements
      const instructionsCard = document.getElementById('instructionsCard');
      const dismissInstructionsButton = document.getElementById('dismissInstructionsButton');
      const fileInput = document.getElementById('fileInput');
      const imageListContainer = document.getElementById('imageListContainer');
      const noImagesMessage = document.getElementById('noImagesMessage');
      const sizingControls = document.getElementById('sizingControls'); // Left panel logic
      const editorPlaceholder = document.getElementById('editorPlaceholder');
      const targetSizeSelect = document.getElementById('targetSizeSelect');
      const customWidthInput = document.getElementById('customWidthInput');
      const customHeightInput = document.getElementById('customHeightInput');
      const setCustomSizeButton = document.getElementById('setCustomSizeButton');
      const canvasContainer = document.getElementById('canvasContainer');
      const editorCanvas = document.getElementById('editorCanvas');
      const ctx = editorCanvas.getContext('2d');
      const canvasSizeDisplay = document.getElementById('canvasSizeDisplay');
      const downloadCurrentImageVersionButton = document.getElementById('downloadCurrentImageVersionButton');
      const currentVersionSizeDisplay = document.getElementById('currentVersionSizeDisplay');
      const toastContainer = document.getElementById('toastContainer');
      const zoomSlider = document.getElementById('zoomSlider');
      const zoomValueDisplay = document.getElementById('zoomValueDisplay');
      const bgColorPicker = document.getElementById('bgColorPicker');
      const hexColorInput = document.getElementById('hexColorInput');
      const transparentBgButton = document.getElementById('transparentBgButton');
      const backgroundOnlyMode = document.getElementById('backgroundOnlyMode');

      const MIN_ZOOM = parseInt(zoomSlider.min, 10) / 100;
      const MAX_ZOOM = parseInt(zoomSlider.max, 10) / 100;
      const INSTRUCTIONS_STORAGE_KEY = 'brutalResizerInstructionsDismissed';

      // App State
      let imagesData = [];
      let activeImageId = null;
      let currentTargetSize = null;
      let originalImageToDraw = null;
      let currentPan = { x: 0, y: 0 };
      let currentZoom = 1.0;
      let currentBackgroundColor = '#FFFFFF';
      let isPanning = false;
      let lastMousePos = { x: 0, y: 0 };
      let isBackgroundOnlyMode = false;
      let previousActiveImageId = null;
      let isPinching = false;
      let initialPinchDistance = 0;
      let initialPinchZoom = 1;
      let lastPinchMidpoint = null;
      let gestureStartZoom = null;

      const PREDEFINED_SIZES = [
          { name: 'Favicon', width: 32, height: 32 },
          { name: 'App Icon', width: 192, height: 192 },
          { name: 'App Icon Lg', width: 512, height: 512 },
          { name: 'Social Post', width: 1080, height: 1080 },
          { name: 'Story 9:16', width: 1080, height: 1920 },
          { name: 'Video 16:9', width: 1920, height: 1080 },
          { name: 'Legacy 4:3', width: 1024, height: 768 },
      ];

      // --- Helpers ---

      function generateImageId() {
          return `img_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
      }

      function getFileNameWithFallback(file) {
          if (file && file.name) return file.name.trim();
          return `upload-${Date.now()}.png`;
      }

      function showToast(message, type = 'info') {
          const toast = document.createElement('div');
          const bgClass = type === 'error' ? 'bg-red-500 text-white' : (type === 'success' ? 'bg-brutal-accent text-black' : 'bg-black text-white');

          toast.className = `${bgClass} p-4 border-4 border-black shadow-brutal font-bold text-sm transform transition-all duration-300 translate-y-10 opacity-0 pointer-events-auto`;
          toast.innerHTML = `<span class="uppercase mr-2">[${type}]</span> ${message}`;

          toastContainer.appendChild(toast);

          // Trigger animation
          requestAnimationFrame(() => {
              toast.classList.remove('translate-y-10', 'opacity-0');
          });

          setTimeout(() => {
              toast.classList.add('translate-y-10', 'opacity-0');
              setTimeout(() => toast.remove(), 300);
          }, 3000);
      }

      // --- Core Logic ---

      function processImageFile(file) {
          const imageId = generateImageId();
          const reader = new FileReader();

          reader.onload = (e) => {
              const imgElement = new Image();
              imgElement.onload = () => {
                  const newImage = {
                      id: imageId,
                      name: getFileNameWithFallback(file),
                      originalSrc: e.target.result,
                      imgElement,
                      processedVersions: {}
                  };

                  imagesData.push(newImage);
                  renderImageListItem(newImage);
                  noImagesMessage.classList.add('hidden');

                  // If it's the first image, select it
                  if (imagesData.length === 1) {
                      setActiveImage(imageId);
                  } else {
                     setActiveImage(imageId);
                  }
                  showToast(`Loaded: ${newImage.name}`, 'success');
              };
              imgElement.src = e.target.result;
          };
          reader.readAsDataURL(file);
      }

      function renderImageListItem(imgData) {
          const item = document.createElement('div');
          item.className = 'flex items-center gap-3 p-2 border-2 border-transparent hover:bg-gray-100 cursor-pointer transition-all group';
          item.dataset.imageId = imgData.id;

          item.innerHTML = `
              <img src="${imgData.originalSrc}" class="w-10 h-10 object-cover border-2 border-black bg-white">
              <span class="text-xs font-bold truncate flex-1">${imgData.name}</span>
              <div class="opacity-0 group-hover:opacity-100 font-bold text-xs text-brutal-accent bg-black px-1">EDIT</div>
          `;

          item.onclick = () => setActiveImage(imgData.id);
          imageListContainer.appendChild(item);
      }

      function setActiveImage(imageId) {
          // Handle Background Only toggle logic
          if (imageId === 'background-only') {
               // Logic handled in toggle listener, just purely visual update here if needed
               return;
          }

          // Reset bg mode if selecting a real image
          if (isBackgroundOnlyMode && imageId !== 'background-only') {
               backgroundOnlyMode.checked = false;
               isBackgroundOnlyMode = false;
          }

          activeImageId = imageId;
          const imgData = imagesData.find(img => img.id === imageId);

          if (!imgData) return;

          originalImageToDraw = imgData.imgElement;

          // UI Updates
          document.querySelectorAll('#imageListContainer > div').forEach(el => {
              el.classList.remove('thumbnail-selected');
              if (el.dataset.imageId === imageId) el.classList.add('thumbnail-selected');
          });

          sizingControls.classList.remove('hidden');
          editorPlaceholder.classList.add('hidden');
          editorCanvas.classList.remove('hidden');

          // Initial setup if size exists, otherwise wait for user to pick size
          if (currentTargetSize) {
              resetZoomAndBgToDefaultsOrStored();
          } else {
              // Auto pick first size for better UX
              targetSizeSelect.value = "192x192";
              handleTargetSizeSelectChange({target: targetSizeSelect});
          }
      }

      function setBackgroundOnlyMode(enabled) {
          isBackgroundOnlyMode = enabled;
          if (enabled) {
              activeImageId = 'background-only';
              originalImageToDraw = null;
              document.querySelectorAll('#imageListContainer > div').forEach(el => el.classList.remove('thumbnail-selected'));
              sizingControls.classList.remove('hidden');
              editorPlaceholder.classList.add('hidden');
              editorCanvas.classList.remove('hidden');
              if(currentTargetSize) resetZoomAndBgToDefaultsOrStored();
              else {
                   targetSizeSelect.value = "192x192";
                   handleTargetSizeSelectChange({target: targetSizeSelect});
              }
          } else {
              // Revert to last image or first image
              if (imagesData.length > 0) {
                  setActiveImage(imagesData[0].id);
              } else {
                  activeImageId = null;
                  sizingControls.classList.add('hidden');
                  editorPlaceholder.classList.remove('hidden');
                  editorCanvas.classList.add('hidden');
              }
          }
          redrawCanvasAndStore();
      }

      // --- Canvas Operations ---

      function resetZoomAndBgToDefaultsOrStored() {
          if (!currentTargetSize) return;

          // Logic: if we have stored settings for this size/image combo, load them.
          // Otherwise calc default 'contain' fit.

          // Simplified default logic for this demo:
          if (!isBackgroundOnlyMode && originalImageToDraw) {
              const zoomX = currentTargetSize.width / originalImageToDraw.naturalWidth;
              const zoomY = currentTargetSize.height / originalImageToDraw.naturalHeight;
              currentZoom = Math.max(zoomX, zoomY); // Cover by default

              const drawWidth = originalImageToDraw.naturalWidth * currentZoom;
              const drawHeight = originalImageToDraw.naturalHeight * currentZoom;

              currentPan.x = (currentTargetSize.width - drawWidth) / 2;
              currentPan.y = (currentTargetSize.height - drawHeight) / 2;
          } else {
              currentZoom = 1;
              currentPan = {x:0, y:0};
          }

          updateZoomDisplay(currentZoom);
          updateCanvasDOM();
      }

      function updateCanvasDOM() {
          if (!currentTargetSize) return;

          editorCanvas.width = currentTargetSize.width;
          editorCanvas.height = currentTargetSize.height;

          // Visual scaling logic (Fit canvas into container visually)
          const containerW = canvasContainer.clientWidth;
          const containerH = canvasContainer.clientHeight;
          const aspect = currentTargetSize.width / currentTargetSize.height;

          let displayW = containerW - 40; // padding
          let displayH = displayW / aspect;

          if (displayH > containerH - 40) {
              displayH = containerH - 40;
              displayW = displayH * aspect;
          }

          editorCanvas.style.width = `${displayW}px`;
          editorCanvas.style.height = `${displayH}px`;

          canvasSizeDisplay.textContent = `${currentTargetSize.width} x ${currentTargetSize.height}`;
          currentVersionSizeDisplay.textContent = `${currentTargetSize.width} x ${currentTargetSize.height}`;
          downloadCurrentImageVersionButton.disabled = false;

          redrawCanvasAndStore();
      }

      function redrawCanvasAndStore() {
          if (!currentTargetSize || !ctx) return;

          // Clear
          ctx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);

          // Fill BG
          if (currentBackgroundColor !== 'transparent') {
              ctx.fillStyle = currentBackgroundColor;
              ctx.fillRect(0, 0, editorCanvas.width, editorCanvas.height);
          }

          // Draw Image
          if (!isBackgroundOnlyMode && originalImageToDraw) {
              const dw = originalImageToDraw.naturalWidth * currentZoom;
              const dh = originalImageToDraw.naturalHeight * currentZoom;
              ctx.drawImage(originalImageToDraw, currentPan.x, currentPan.y, dw, dh);
          }
      }

      // --- Interactions ---

      function handleTargetSizeSelectChange(e) {
          const val = e.target.value;
          if (!val) return;
          const [w, h] = val.split('x').map(Number);
          currentTargetSize = { width: w, height: h };
          customWidthInput.value = w;
          customHeightInput.value = h;
          resetZoomAndBgToDefaultsOrStored();
      }

      function handleCustomSize() {
          const w = parseInt(customWidthInput.value);
          const h = parseInt(customHeightInput.value);
          if (w > 0 && h > 0) {
              currentTargetSize = { width: w, height: h };
              targetSizeSelect.value = ""; // Reset dropdown
              resetZoomAndBgToDefaultsOrStored();
          } else {
              showToast('Invalid dimensions', 'error');
          }
      }

      // Zoom
      function applyZoom(newZoom) {
          // Clamp
          if (newZoom < MIN_ZOOM) newZoom = MIN_ZOOM;
          if (newZoom > MAX_ZOOM) newZoom = MAX_ZOOM;

          // Simple center zoom for slider
          // (Detailed pan-aware zoom omitted for brevity, keeping it robust)
          const scaleFactor = newZoom / currentZoom;

          // Adjust pan to zoom towards center of canvas
          const canvasCenterX = currentTargetSize.width / 2;
          const canvasCenterY = currentTargetSize.height / 2;

          currentPan.x = canvasCenterX - (canvasCenterX - currentPan.x) * scaleFactor;
          currentPan.y = canvasCenterY - (canvasCenterY - currentPan.y) * scaleFactor;

          currentZoom = newZoom;
          updateZoomDisplay(currentZoom);
          redrawCanvasAndStore();
      }

      function updateZoomDisplay(val) {
          const pct = Math.round(val * 100);
          zoomSlider.value = pct;
          zoomValueDisplay.textContent = pct + "%";
      }

      // Panning
      function startPan(e) {
          if (!currentTargetSize) return;
          e.preventDefault();
          isPanning = true;
          editorCanvas.classList.add('cursor-grabbing');
          editorCanvas.classList.remove('cursor-grab');

          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          lastMousePos = { x: clientX, y: clientY };
      }

      function doPan(e) {
          if (!isPanning) return;
          e.preventDefault();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;

          // Calculate delta based on visual size vs actual size
          const visualRect = editorCanvas.getBoundingClientRect();
          const scaleX = editorCanvas.width / visualRect.width;
          const scaleY = editorCanvas.height / visualRect.height;

          const dx = (clientX - lastMousePos.x) * scaleX;
          const dy = (clientY - lastMousePos.y) * scaleY;

          currentPan.x += dx;
          currentPan.y += dy;

          lastMousePos = { x: clientX, y: clientY };
          redrawCanvasAndStore();
      }

      function endPan() {
          isPanning = false;
          editorCanvas.classList.remove('cursor-grabbing');
          editorCanvas.classList.add('cursor-grab');
      }

      function handleWheel(e) {
          if (!currentTargetSize) return;
          e.preventDefault();
          const delta = -e.deltaY * 0.001;
          applyZoom(currentZoom + (currentZoom * delta));
      }

      // Download
      function download() {
          if (!currentTargetSize) return;
          const link = document.createElement('a');
          link.download = `rawcrop_${currentTargetSize.width}x${currentTargetSize.height}_${Date.now()}.png`;
          link.href = editorCanvas.toDataURL('image/png');
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          showToast('Image Exported', 'success');
      }

      // --- Initialization ---

      document.addEventListener('DOMContentLoaded', () => {
          // Populate Select
          PREDEFINED_SIZES.forEach(s => {
              const opt = document.createElement('option');
              opt.value = `${s.width}x${s.height}`;
              opt.text = `${s.name.toUpperCase()} (${s.width}x${s.height})`;
              targetSizeSelect.appendChild(opt);
          });

          // Event Listeners
          fileInput.addEventListener('change', (e) => {
              Array.from(e.target.files).forEach(processImageFile);
              e.target.value = '';
          });

          targetSizeSelect.addEventListener('change', handleTargetSizeSelectChange);
          setCustomSizeButton.addEventListener('click', handleCustomSize);

          zoomSlider.addEventListener('input', (e) => applyZoom(parseInt(e.target.value)/100));

          bgColorPicker.addEventListener('input', (e) => {
              currentBackgroundColor = e.target.value;
              hexColorInput.value = currentBackgroundColor;
              redrawCanvasAndStore();
          });

          hexColorInput.addEventListener('change', (e) => {
              let val = e.target.value;
              if(!val.startsWith('#')) val = '#' + val;
              if(/^#[0-9A-F]{6}$/i.test(val)) {
                  currentBackgroundColor = val;
                  bgColorPicker.value = val;
                  redrawCanvasAndStore();
              }
          });

          transparentBgButton.addEventListener('click', () => {
              currentBackgroundColor = 'transparent';
              hexColorInput.value = 'TRANSPARENT';
              redrawCanvasAndStore();
              showToast('Background: Transparent');
          });

          backgroundOnlyMode.addEventListener('change', (e) => {
              setBackgroundOnlyMode(e.target.checked);
          });

          downloadCurrentImageVersionButton.addEventListener('click', download);

          // Canvas Events
          editorCanvas.addEventListener('mousedown', startPan);
          window.addEventListener('mousemove', doPan); // Window allows dragging outside canvas
          window.addEventListener('mouseup', endPan);

          editorCanvas.addEventListener('touchstart', startPan, {passive: false});
          editorCanvas.addEventListener('touchmove', doPan, {passive: false});
          editorCanvas.addEventListener('touchend', endPan);

          canvasContainer.addEventListener('wheel', handleWheel, {passive: false});

          dismissInstructionsButton.addEventListener('click', () => {
              instructionsCard.style.display = 'none';
          });
      });
    </script>
  </body>
</html>
